-- Do not manually edit this file, it was auto-generated by Graphqelm
-- https://github.com/dillonkearns/graphqelm


module WatchWord.Object.Game exposing (..)

import Graphqelm.Field as Field exposing (Field)
import Graphqelm.Internal.Builder.Argument as Argument exposing (Argument)
import Graphqelm.Internal.Builder.Object as Object
import Graphqelm.Internal.Encode as Encode exposing (Value)
import Graphqelm.OptionalArgument exposing (OptionalArgument(Absent))
import Graphqelm.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode
import WatchWord.Enum.Focus
import WatchWord.Enum.SessionOrderByInput
import WatchWord.Enum.WordOrderByInput
import WatchWord.InputObject
import WatchWord.Interface
import WatchWord.Object
import WatchWord.Scalar
import WatchWord.Union


{-| Select fields to build up a SelectionSet for this object.
-}
selection : (a -> constructor) -> SelectionSet (a -> constructor) WatchWord.Object.Game
selection constructor =
    Object.selection constructor


{-| -}
id : Field WatchWord.Scalar.Id WatchWord.Object.Game
id =
    Object.fieldDecoder "id" [] (Decode.oneOf [ Decode.string, Decode.float |> Decode.map toString, Decode.int |> Decode.map toString, Decode.bool |> Decode.map toString ] |> Decode.map WatchWord.Scalar.Id)


{-| -}
createdAt : Field WatchWord.Scalar.DateTime WatchWord.Object.Game
createdAt =
    Object.fieldDecoder "createdAt" [] (Decode.oneOf [ Decode.string, Decode.float |> Decode.map toString, Decode.int |> Decode.map toString, Decode.bool |> Decode.map toString ] |> Decode.map WatchWord.Scalar.DateTime)


{-| -}
updatedAt : Field WatchWord.Scalar.DateTime WatchWord.Object.Game
updatedAt =
    Object.fieldDecoder "updatedAt" [] (Decode.oneOf [ Decode.string, Decode.float |> Decode.map toString, Decode.int |> Decode.map toString, Decode.bool |> Decode.map toString ] |> Decode.map WatchWord.Scalar.DateTime)


type alias PatternOptionalArguments =
    { where_ : OptionalArgument WatchWord.InputObject.PatternWhereInput }


{-|

  - where_ -

-}
pattern : (PatternOptionalArguments -> PatternOptionalArguments) -> SelectionSet decodesTo WatchWord.Object.Pattern -> Field decodesTo WatchWord.Object.Game
pattern fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ WatchWord.InputObject.encodePatternWhereInput ]
                |> List.filterMap identity
    in
    Object.selectionField "pattern" optionalArgs object identity


type alias SessionsOptionalArguments =
    { where_ : OptionalArgument WatchWord.InputObject.SessionWhereInput, orderBy : OptionalArgument WatchWord.Enum.SessionOrderByInput.SessionOrderByInput, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-|

  - where_ -
  - orderBy -
  - skip -
  - after -
  - before -
  - first -
  - last -

-}
sessions : (SessionsOptionalArguments -> SessionsOptionalArguments) -> SelectionSet decodesTo WatchWord.Object.Session -> Field (Maybe (List decodesTo)) WatchWord.Object.Game
sessions fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ WatchWord.InputObject.encodeSessionWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum WatchWord.Enum.SessionOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "sessions" optionalArgs object (identity >> Decode.list >> Decode.nullable)


type alias OwnerOptionalArguments =
    { where_ : OptionalArgument WatchWord.InputObject.UserWhereInput }


{-|

  - where_ -

-}
owner : (OwnerOptionalArguments -> OwnerOptionalArguments) -> SelectionSet decodesTo WatchWord.Object.User -> Field decodesTo WatchWord.Object.Game
owner fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ WatchWord.InputObject.encodeUserWhereInput ]
                |> List.filterMap identity
    in
    Object.selectionField "owner" optionalArgs object identity


{-| -}
focus : Field WatchWord.Enum.Focus.Focus WatchWord.Object.Game
focus =
    Object.fieldDecoder "focus" [] WatchWord.Enum.Focus.decoder


{-| -}
size : Field Int WatchWord.Object.Game
size =
    Object.fieldDecoder "size" [] Decode.int


type alias WordsOptionalArguments =
    { where_ : OptionalArgument WatchWord.InputObject.WordWhereInput, orderBy : OptionalArgument WatchWord.Enum.WordOrderByInput.WordOrderByInput, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-|

  - where_ -
  - orderBy -
  - skip -
  - after -
  - before -
  - first -
  - last -

-}
words : (WordsOptionalArguments -> WordsOptionalArguments) -> SelectionSet decodesTo WatchWord.Object.Word -> Field (Maybe (List decodesTo)) WatchWord.Object.Game
words fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ WatchWord.InputObject.encodeWordWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum WatchWord.Enum.WordOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "words" optionalArgs object (identity >> Decode.list >> Decode.nullable)


{-| -}
name : Field String WatchWord.Object.Game
name =
    Object.fieldDecoder "name" [] Decode.string
