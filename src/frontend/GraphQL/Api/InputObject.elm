-- Do not manually edit this file, it was auto-generated by Graphqelm
-- https://github.com/dillonkearns/graphqelm


module Api.InputObject exposing (..)

import Api.Enum.MutationType
import Api.Interface
import Api.Object
import Api.Scalar
import Api.Union
import Graphqelm.Field as Field exposing (Field)
import Graphqelm.Internal.Builder.Argument as Argument exposing (Argument)
import Graphqelm.Internal.Builder.Object as Object
import Graphqelm.Internal.Encode as Encode exposing (Value)
import Graphqelm.OptionalArgument exposing (OptionalArgument(Absent))
import Graphqelm.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildExerciseCreateInput : ExerciseCreateInputRequiredFields -> (ExerciseCreateInputOptionalFields -> ExerciseCreateInputOptionalFields) -> ExerciseCreateInput
buildExerciseCreateInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { views = Absent, completed = Absent }
    in
    { views = optionals.views, completed = optionals.completed, game = required.game, owner = required.owner }


type alias ExerciseCreateInputRequiredFields =
    { game : GameCreateOneInput, owner : UserCreateOneWithoutExercisesInput }


type alias ExerciseCreateInputOptionalFields =
    { views : OptionalArgument Int, completed : OptionalArgument Int }


{-| Type for the ExerciseCreateInput input object.
-}
type alias ExerciseCreateInput =
    { views : OptionalArgument Int, completed : OptionalArgument Int, game : GameCreateOneInput, owner : UserCreateOneWithoutExercisesInput }


{-| Encode a ExerciseCreateInput into a value that can be used as an argument.
-}
encodeExerciseCreateInput : ExerciseCreateInput -> Value
encodeExerciseCreateInput input =
    Encode.maybeObject
        [ ( "views", Encode.int |> Encode.optional input.views ), ( "completed", Encode.int |> Encode.optional input.completed ), ( "game", encodeGameCreateOneInput input.game |> Just ), ( "owner", encodeUserCreateOneWithoutExercisesInput input.owner |> Just ) ]


buildExerciseCreateManyWithoutOwnerInput : (ExerciseCreateManyWithoutOwnerInputOptionalFields -> ExerciseCreateManyWithoutOwnerInputOptionalFields) -> ExerciseCreateManyWithoutOwnerInput
buildExerciseCreateManyWithoutOwnerInput fillOptionals =
    let
        optionals =
            fillOptionals
                { create = Absent, connect = Absent }
    in
    ExerciseCreateManyWithoutOwnerInput { create = optionals.create, connect = optionals.connect }


type alias ExerciseCreateManyWithoutOwnerInputOptionalFields =
    { create : OptionalArgument (List ExerciseCreateWithoutOwnerInput), connect : OptionalArgument (List ExerciseWhereUniqueInput) }


{-| Type alias for the `ExerciseCreateManyWithoutOwnerInput` attributes. Note that this type
needs to use the `ExerciseCreateManyWithoutOwnerInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/graphqelm/issues/33>.
-}
type alias ExerciseCreateManyWithoutOwnerInputRaw =
    { create : OptionalArgument (List ExerciseCreateWithoutOwnerInput), connect : OptionalArgument (List ExerciseWhereUniqueInput) }


{-| Type for the ExerciseCreateManyWithoutOwnerInput input object.
-}
type ExerciseCreateManyWithoutOwnerInput
    = ExerciseCreateManyWithoutOwnerInput ExerciseCreateManyWithoutOwnerInputRaw


{-| Encode a ExerciseCreateManyWithoutOwnerInput into a value that can be used as an argument.
-}
encodeExerciseCreateManyWithoutOwnerInput : ExerciseCreateManyWithoutOwnerInput -> Value
encodeExerciseCreateManyWithoutOwnerInput (ExerciseCreateManyWithoutOwnerInput input) =
    Encode.maybeObject
        [ ( "create", (encodeExerciseCreateWithoutOwnerInput |> Encode.list) |> Encode.optional input.create ), ( "connect", (encodeExerciseWhereUniqueInput |> Encode.list) |> Encode.optional input.connect ) ]


buildExerciseCreateWithoutOwnerInput : ExerciseCreateWithoutOwnerInputRequiredFields -> (ExerciseCreateWithoutOwnerInputOptionalFields -> ExerciseCreateWithoutOwnerInputOptionalFields) -> ExerciseCreateWithoutOwnerInput
buildExerciseCreateWithoutOwnerInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { views = Absent, completed = Absent }
    in
    { views = optionals.views, completed = optionals.completed, game = required.game }


type alias ExerciseCreateWithoutOwnerInputRequiredFields =
    { game : GameCreateOneInput }


type alias ExerciseCreateWithoutOwnerInputOptionalFields =
    { views : OptionalArgument Int, completed : OptionalArgument Int }


{-| Type for the ExerciseCreateWithoutOwnerInput input object.
-}
type alias ExerciseCreateWithoutOwnerInput =
    { views : OptionalArgument Int, completed : OptionalArgument Int, game : GameCreateOneInput }


{-| Encode a ExerciseCreateWithoutOwnerInput into a value that can be used as an argument.
-}
encodeExerciseCreateWithoutOwnerInput : ExerciseCreateWithoutOwnerInput -> Value
encodeExerciseCreateWithoutOwnerInput input =
    Encode.maybeObject
        [ ( "views", Encode.int |> Encode.optional input.views ), ( "completed", Encode.int |> Encode.optional input.completed ), ( "game", encodeGameCreateOneInput input.game |> Just ) ]


buildExerciseSubscriptionWhereInput : (ExerciseSubscriptionWhereInputOptionalFields -> ExerciseSubscriptionWhereInputOptionalFields) -> ExerciseSubscriptionWhereInput
buildExerciseSubscriptionWhereInput fillOptionals =
    let
        optionals =
            fillOptionals
                { and = Absent, or = Absent, not = Absent, mutation_in = Absent, updatedFields_contains = Absent, updatedFields_contains_every = Absent, updatedFields_contains_some = Absent, node = Absent }
    in
    ExerciseSubscriptionWhereInput { and = optionals.and, or = optionals.or, not = optionals.not, mutation_in = optionals.mutation_in, updatedFields_contains = optionals.updatedFields_contains, updatedFields_contains_every = optionals.updatedFields_contains_every, updatedFields_contains_some = optionals.updatedFields_contains_some, node = optionals.node }


type alias ExerciseSubscriptionWhereInputOptionalFields =
    { and : OptionalArgument (List ExerciseSubscriptionWhereInput), or : OptionalArgument (List ExerciseSubscriptionWhereInput), not : OptionalArgument (List ExerciseSubscriptionWhereInput), mutation_in : OptionalArgument (List Api.Enum.MutationType.MutationType), updatedFields_contains : OptionalArgument String, updatedFields_contains_every : OptionalArgument (List String), updatedFields_contains_some : OptionalArgument (List String), node : OptionalArgument ExerciseWhereInput }


{-| Type alias for the `ExerciseSubscriptionWhereInput` attributes. Note that this type
needs to use the `ExerciseSubscriptionWhereInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/graphqelm/issues/33>.
-}
type alias ExerciseSubscriptionWhereInputRaw =
    { and : OptionalArgument (List ExerciseSubscriptionWhereInput), or : OptionalArgument (List ExerciseSubscriptionWhereInput), not : OptionalArgument (List ExerciseSubscriptionWhereInput), mutation_in : OptionalArgument (List Api.Enum.MutationType.MutationType), updatedFields_contains : OptionalArgument String, updatedFields_contains_every : OptionalArgument (List String), updatedFields_contains_some : OptionalArgument (List String), node : OptionalArgument ExerciseWhereInput }


{-| Type for the ExerciseSubscriptionWhereInput input object.
-}
type ExerciseSubscriptionWhereInput
    = ExerciseSubscriptionWhereInput ExerciseSubscriptionWhereInputRaw


{-| Encode a ExerciseSubscriptionWhereInput into a value that can be used as an argument.
-}
encodeExerciseSubscriptionWhereInput : ExerciseSubscriptionWhereInput -> Value
encodeExerciseSubscriptionWhereInput (ExerciseSubscriptionWhereInput input) =
    Encode.maybeObject
        [ ( "AND", (encodeExerciseSubscriptionWhereInput |> Encode.list) |> Encode.optional input.and ), ( "OR", (encodeExerciseSubscriptionWhereInput |> Encode.list) |> Encode.optional input.or ), ( "NOT", (encodeExerciseSubscriptionWhereInput |> Encode.list) |> Encode.optional input.not ), ( "mutation_in", (Encode.enum Api.Enum.MutationType.toString |> Encode.list) |> Encode.optional input.mutation_in ), ( "updatedFields_contains", Encode.string |> Encode.optional input.updatedFields_contains ), ( "updatedFields_contains_every", (Encode.string |> Encode.list) |> Encode.optional input.updatedFields_contains_every ), ( "updatedFields_contains_some", (Encode.string |> Encode.list) |> Encode.optional input.updatedFields_contains_some ), ( "node", encodeExerciseWhereInput |> Encode.optional input.node ) ]


buildExerciseUpdateInput : (ExerciseUpdateInputOptionalFields -> ExerciseUpdateInputOptionalFields) -> ExerciseUpdateInput
buildExerciseUpdateInput fillOptionals =
    let
        optionals =
            fillOptionals
                { views = Absent, completed = Absent, game = Absent, owner = Absent }
    in
    ExerciseUpdateInput { views = optionals.views, completed = optionals.completed, game = optionals.game, owner = optionals.owner }


type alias ExerciseUpdateInputOptionalFields =
    { views : OptionalArgument Int, completed : OptionalArgument Int, game : OptionalArgument GameUpdateOneInput, owner : OptionalArgument UserUpdateOneWithoutExercisesInput }


{-| Type alias for the `ExerciseUpdateInput` attributes. Note that this type
needs to use the `ExerciseUpdateInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/graphqelm/issues/33>.
-}
type alias ExerciseUpdateInputRaw =
    { views : OptionalArgument Int, completed : OptionalArgument Int, game : OptionalArgument GameUpdateOneInput, owner : OptionalArgument UserUpdateOneWithoutExercisesInput }


{-| Type for the ExerciseUpdateInput input object.
-}
type ExerciseUpdateInput
    = ExerciseUpdateInput ExerciseUpdateInputRaw


{-| Encode a ExerciseUpdateInput into a value that can be used as an argument.
-}
encodeExerciseUpdateInput : ExerciseUpdateInput -> Value
encodeExerciseUpdateInput (ExerciseUpdateInput input) =
    Encode.maybeObject
        [ ( "views", Encode.int |> Encode.optional input.views ), ( "completed", Encode.int |> Encode.optional input.completed ), ( "game", encodeGameUpdateOneInput |> Encode.optional input.game ), ( "owner", encodeUserUpdateOneWithoutExercisesInput |> Encode.optional input.owner ) ]


buildExerciseUpdateManyWithoutOwnerInput : (ExerciseUpdateManyWithoutOwnerInputOptionalFields -> ExerciseUpdateManyWithoutOwnerInputOptionalFields) -> ExerciseUpdateManyWithoutOwnerInput
buildExerciseUpdateManyWithoutOwnerInput fillOptionals =
    let
        optionals =
            fillOptionals
                { create = Absent, connect = Absent, disconnect = Absent, delete = Absent, update = Absent, upsert = Absent }
    in
    ExerciseUpdateManyWithoutOwnerInput { create = optionals.create, connect = optionals.connect, disconnect = optionals.disconnect, delete = optionals.delete, update = optionals.update, upsert = optionals.upsert }


type alias ExerciseUpdateManyWithoutOwnerInputOptionalFields =
    { create : OptionalArgument (List ExerciseCreateWithoutOwnerInput), connect : OptionalArgument (List ExerciseWhereUniqueInput), disconnect : OptionalArgument (List ExerciseWhereUniqueInput), delete : OptionalArgument (List ExerciseWhereUniqueInput), update : OptionalArgument (List ExerciseUpdateWithWhereUniqueWithoutOwnerInput), upsert : OptionalArgument (List ExerciseUpsertWithWhereUniqueWithoutOwnerInput) }


{-| Type alias for the `ExerciseUpdateManyWithoutOwnerInput` attributes. Note that this type
needs to use the `ExerciseUpdateManyWithoutOwnerInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/graphqelm/issues/33>.
-}
type alias ExerciseUpdateManyWithoutOwnerInputRaw =
    { create : OptionalArgument (List ExerciseCreateWithoutOwnerInput), connect : OptionalArgument (List ExerciseWhereUniqueInput), disconnect : OptionalArgument (List ExerciseWhereUniqueInput), delete : OptionalArgument (List ExerciseWhereUniqueInput), update : OptionalArgument (List ExerciseUpdateWithWhereUniqueWithoutOwnerInput), upsert : OptionalArgument (List ExerciseUpsertWithWhereUniqueWithoutOwnerInput) }


{-| Type for the ExerciseUpdateManyWithoutOwnerInput input object.
-}
type ExerciseUpdateManyWithoutOwnerInput
    = ExerciseUpdateManyWithoutOwnerInput ExerciseUpdateManyWithoutOwnerInputRaw


{-| Encode a ExerciseUpdateManyWithoutOwnerInput into a value that can be used as an argument.
-}
encodeExerciseUpdateManyWithoutOwnerInput : ExerciseUpdateManyWithoutOwnerInput -> Value
encodeExerciseUpdateManyWithoutOwnerInput (ExerciseUpdateManyWithoutOwnerInput input) =
    Encode.maybeObject
        [ ( "create", (encodeExerciseCreateWithoutOwnerInput |> Encode.list) |> Encode.optional input.create ), ( "connect", (encodeExerciseWhereUniqueInput |> Encode.list) |> Encode.optional input.connect ), ( "disconnect", (encodeExerciseWhereUniqueInput |> Encode.list) |> Encode.optional input.disconnect ), ( "delete", (encodeExerciseWhereUniqueInput |> Encode.list) |> Encode.optional input.delete ), ( "update", (encodeExerciseUpdateWithWhereUniqueWithoutOwnerInput |> Encode.list) |> Encode.optional input.update ), ( "upsert", (encodeExerciseUpsertWithWhereUniqueWithoutOwnerInput |> Encode.list) |> Encode.optional input.upsert ) ]


buildExerciseUpdateWithWhereUniqueWithoutOwnerInput : ExerciseUpdateWithWhereUniqueWithoutOwnerInputRequiredFields -> ExerciseUpdateWithWhereUniqueWithoutOwnerInput
buildExerciseUpdateWithWhereUniqueWithoutOwnerInput required =
    ExerciseUpdateWithWhereUniqueWithoutOwnerInput { where_ = required.where_, data = required.data }


type alias ExerciseUpdateWithWhereUniqueWithoutOwnerInputRequiredFields =
    { where_ : ExerciseWhereUniqueInput, data : ExerciseUpdateWithoutOwnerDataInput }


{-| Type alias for the `ExerciseUpdateWithWhereUniqueWithoutOwnerInput` attributes. Note that this type
needs to use the `ExerciseUpdateWithWhereUniqueWithoutOwnerInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/graphqelm/issues/33>.
-}
type alias ExerciseUpdateWithWhereUniqueWithoutOwnerInputRaw =
    { where_ : ExerciseWhereUniqueInput, data : ExerciseUpdateWithoutOwnerDataInput }


{-| Type for the ExerciseUpdateWithWhereUniqueWithoutOwnerInput input object.
-}
type ExerciseUpdateWithWhereUniqueWithoutOwnerInput
    = ExerciseUpdateWithWhereUniqueWithoutOwnerInput ExerciseUpdateWithWhereUniqueWithoutOwnerInputRaw


{-| Encode a ExerciseUpdateWithWhereUniqueWithoutOwnerInput into a value that can be used as an argument.
-}
encodeExerciseUpdateWithWhereUniqueWithoutOwnerInput : ExerciseUpdateWithWhereUniqueWithoutOwnerInput -> Value
encodeExerciseUpdateWithWhereUniqueWithoutOwnerInput (ExerciseUpdateWithWhereUniqueWithoutOwnerInput input) =
    Encode.maybeObject
        [ ( "where", encodeExerciseWhereUniqueInput input.where_ |> Just ), ( "data", encodeExerciseUpdateWithoutOwnerDataInput input.data |> Just ) ]


buildExerciseUpdateWithoutOwnerDataInput : (ExerciseUpdateWithoutOwnerDataInputOptionalFields -> ExerciseUpdateWithoutOwnerDataInputOptionalFields) -> ExerciseUpdateWithoutOwnerDataInput
buildExerciseUpdateWithoutOwnerDataInput fillOptionals =
    let
        optionals =
            fillOptionals
                { views = Absent, completed = Absent, game = Absent }
    in
    ExerciseUpdateWithoutOwnerDataInput { views = optionals.views, completed = optionals.completed, game = optionals.game }


type alias ExerciseUpdateWithoutOwnerDataInputOptionalFields =
    { views : OptionalArgument Int, completed : OptionalArgument Int, game : OptionalArgument GameUpdateOneInput }


{-| Type alias for the `ExerciseUpdateWithoutOwnerDataInput` attributes. Note that this type
needs to use the `ExerciseUpdateWithoutOwnerDataInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/graphqelm/issues/33>.
-}
type alias ExerciseUpdateWithoutOwnerDataInputRaw =
    { views : OptionalArgument Int, completed : OptionalArgument Int, game : OptionalArgument GameUpdateOneInput }


{-| Type for the ExerciseUpdateWithoutOwnerDataInput input object.
-}
type ExerciseUpdateWithoutOwnerDataInput
    = ExerciseUpdateWithoutOwnerDataInput ExerciseUpdateWithoutOwnerDataInputRaw


{-| Encode a ExerciseUpdateWithoutOwnerDataInput into a value that can be used as an argument.
-}
encodeExerciseUpdateWithoutOwnerDataInput : ExerciseUpdateWithoutOwnerDataInput -> Value
encodeExerciseUpdateWithoutOwnerDataInput (ExerciseUpdateWithoutOwnerDataInput input) =
    Encode.maybeObject
        [ ( "views", Encode.int |> Encode.optional input.views ), ( "completed", Encode.int |> Encode.optional input.completed ), ( "game", encodeGameUpdateOneInput |> Encode.optional input.game ) ]


buildExerciseUpsertWithWhereUniqueWithoutOwnerInput : ExerciseUpsertWithWhereUniqueWithoutOwnerInputRequiredFields -> ExerciseUpsertWithWhereUniqueWithoutOwnerInput
buildExerciseUpsertWithWhereUniqueWithoutOwnerInput required =
    ExerciseUpsertWithWhereUniqueWithoutOwnerInput { where_ = required.where_, update = required.update, create = required.create }


type alias ExerciseUpsertWithWhereUniqueWithoutOwnerInputRequiredFields =
    { where_ : ExerciseWhereUniqueInput, update : ExerciseUpdateWithoutOwnerDataInput, create : ExerciseCreateWithoutOwnerInput }


{-| Type alias for the `ExerciseUpsertWithWhereUniqueWithoutOwnerInput` attributes. Note that this type
needs to use the `ExerciseUpsertWithWhereUniqueWithoutOwnerInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/graphqelm/issues/33>.
-}
type alias ExerciseUpsertWithWhereUniqueWithoutOwnerInputRaw =
    { where_ : ExerciseWhereUniqueInput, update : ExerciseUpdateWithoutOwnerDataInput, create : ExerciseCreateWithoutOwnerInput }


{-| Type for the ExerciseUpsertWithWhereUniqueWithoutOwnerInput input object.
-}
type ExerciseUpsertWithWhereUniqueWithoutOwnerInput
    = ExerciseUpsertWithWhereUniqueWithoutOwnerInput ExerciseUpsertWithWhereUniqueWithoutOwnerInputRaw


{-| Encode a ExerciseUpsertWithWhereUniqueWithoutOwnerInput into a value that can be used as an argument.
-}
encodeExerciseUpsertWithWhereUniqueWithoutOwnerInput : ExerciseUpsertWithWhereUniqueWithoutOwnerInput -> Value
encodeExerciseUpsertWithWhereUniqueWithoutOwnerInput (ExerciseUpsertWithWhereUniqueWithoutOwnerInput input) =
    Encode.maybeObject
        [ ( "where", encodeExerciseWhereUniqueInput input.where_ |> Just ), ( "update", encodeExerciseUpdateWithoutOwnerDataInput input.update |> Just ), ( "create", encodeExerciseCreateWithoutOwnerInput input.create |> Just ) ]


buildExerciseWhereInput : (ExerciseWhereInputOptionalFields -> ExerciseWhereInputOptionalFields) -> ExerciseWhereInput
buildExerciseWhereInput fillOptionals =
    let
        optionals =
            fillOptionals
                { and = Absent, or = Absent, not = Absent, id = Absent, id_not = Absent, id_in = Absent, id_not_in = Absent, id_lt = Absent, id_lte = Absent, id_gt = Absent, id_gte = Absent, id_contains = Absent, id_not_contains = Absent, id_starts_with = Absent, id_not_starts_with = Absent, id_ends_with = Absent, id_not_ends_with = Absent, views = Absent, views_not = Absent, views_in = Absent, views_not_in = Absent, views_lt = Absent, views_lte = Absent, views_gt = Absent, views_gte = Absent, completed = Absent, completed_not = Absent, completed_in = Absent, completed_not_in = Absent, completed_lt = Absent, completed_lte = Absent, completed_gt = Absent, completed_gte = Absent, game = Absent, owner = Absent }
    in
    ExerciseWhereInput { and = optionals.and, or = optionals.or, not = optionals.not, id = optionals.id, id_not = optionals.id_not, id_in = optionals.id_in, id_not_in = optionals.id_not_in, id_lt = optionals.id_lt, id_lte = optionals.id_lte, id_gt = optionals.id_gt, id_gte = optionals.id_gte, id_contains = optionals.id_contains, id_not_contains = optionals.id_not_contains, id_starts_with = optionals.id_starts_with, id_not_starts_with = optionals.id_not_starts_with, id_ends_with = optionals.id_ends_with, id_not_ends_with = optionals.id_not_ends_with, views = optionals.views, views_not = optionals.views_not, views_in = optionals.views_in, views_not_in = optionals.views_not_in, views_lt = optionals.views_lt, views_lte = optionals.views_lte, views_gt = optionals.views_gt, views_gte = optionals.views_gte, completed = optionals.completed, completed_not = optionals.completed_not, completed_in = optionals.completed_in, completed_not_in = optionals.completed_not_in, completed_lt = optionals.completed_lt, completed_lte = optionals.completed_lte, completed_gt = optionals.completed_gt, completed_gte = optionals.completed_gte, game = optionals.game, owner = optionals.owner }


type alias ExerciseWhereInputOptionalFields =
    { and : OptionalArgument (List ExerciseWhereInput), or : OptionalArgument (List ExerciseWhereInput), not : OptionalArgument (List ExerciseWhereInput), id : OptionalArgument Api.Scalar.Id, id_not : OptionalArgument Api.Scalar.Id, id_in : OptionalArgument (List Api.Scalar.Id), id_not_in : OptionalArgument (List Api.Scalar.Id), id_lt : OptionalArgument Api.Scalar.Id, id_lte : OptionalArgument Api.Scalar.Id, id_gt : OptionalArgument Api.Scalar.Id, id_gte : OptionalArgument Api.Scalar.Id, id_contains : OptionalArgument Api.Scalar.Id, id_not_contains : OptionalArgument Api.Scalar.Id, id_starts_with : OptionalArgument Api.Scalar.Id, id_not_starts_with : OptionalArgument Api.Scalar.Id, id_ends_with : OptionalArgument Api.Scalar.Id, id_not_ends_with : OptionalArgument Api.Scalar.Id, views : OptionalArgument Int, views_not : OptionalArgument Int, views_in : OptionalArgument (List Int), views_not_in : OptionalArgument (List Int), views_lt : OptionalArgument Int, views_lte : OptionalArgument Int, views_gt : OptionalArgument Int, views_gte : OptionalArgument Int, completed : OptionalArgument Int, completed_not : OptionalArgument Int, completed_in : OptionalArgument (List Int), completed_not_in : OptionalArgument (List Int), completed_lt : OptionalArgument Int, completed_lte : OptionalArgument Int, completed_gt : OptionalArgument Int, completed_gte : OptionalArgument Int, game : OptionalArgument GameWhereInput, owner : OptionalArgument UserWhereInput }


{-| Type alias for the `ExerciseWhereInput` attributes. Note that this type
needs to use the `ExerciseWhereInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/graphqelm/issues/33>.
-}
type alias ExerciseWhereInputRaw =
    { and : OptionalArgument (List ExerciseWhereInput), or : OptionalArgument (List ExerciseWhereInput), not : OptionalArgument (List ExerciseWhereInput), id : OptionalArgument Api.Scalar.Id, id_not : OptionalArgument Api.Scalar.Id, id_in : OptionalArgument (List Api.Scalar.Id), id_not_in : OptionalArgument (List Api.Scalar.Id), id_lt : OptionalArgument Api.Scalar.Id, id_lte : OptionalArgument Api.Scalar.Id, id_gt : OptionalArgument Api.Scalar.Id, id_gte : OptionalArgument Api.Scalar.Id, id_contains : OptionalArgument Api.Scalar.Id, id_not_contains : OptionalArgument Api.Scalar.Id, id_starts_with : OptionalArgument Api.Scalar.Id, id_not_starts_with : OptionalArgument Api.Scalar.Id, id_ends_with : OptionalArgument Api.Scalar.Id, id_not_ends_with : OptionalArgument Api.Scalar.Id, views : OptionalArgument Int, views_not : OptionalArgument Int, views_in : OptionalArgument (List Int), views_not_in : OptionalArgument (List Int), views_lt : OptionalArgument Int, views_lte : OptionalArgument Int, views_gt : OptionalArgument Int, views_gte : OptionalArgument Int, completed : OptionalArgument Int, completed_not : OptionalArgument Int, completed_in : OptionalArgument (List Int), completed_not_in : OptionalArgument (List Int), completed_lt : OptionalArgument Int, completed_lte : OptionalArgument Int, completed_gt : OptionalArgument Int, completed_gte : OptionalArgument Int, game : OptionalArgument GameWhereInput, owner : OptionalArgument UserWhereInput }


{-| Type for the ExerciseWhereInput input object.
-}
type ExerciseWhereInput
    = ExerciseWhereInput ExerciseWhereInputRaw


{-| Encode a ExerciseWhereInput into a value that can be used as an argument.
-}
encodeExerciseWhereInput : ExerciseWhereInput -> Value
encodeExerciseWhereInput (ExerciseWhereInput input) =
    Encode.maybeObject
        [ ( "AND", (encodeExerciseWhereInput |> Encode.list) |> Encode.optional input.and ), ( "OR", (encodeExerciseWhereInput |> Encode.list) |> Encode.optional input.or ), ( "NOT", (encodeExerciseWhereInput |> Encode.list) |> Encode.optional input.not ), ( "id", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id ), ( "id_not", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_not ), ( "id_in", ((\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.list) |> Encode.optional input.id_in ), ( "id_not_in", ((\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.list) |> Encode.optional input.id_not_in ), ( "id_lt", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_lt ), ( "id_lte", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_lte ), ( "id_gt", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_gt ), ( "id_gte", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_gte ), ( "id_contains", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_contains ), ( "id_not_contains", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_not_contains ), ( "id_starts_with", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_starts_with ), ( "id_not_starts_with", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_not_starts_with ), ( "id_ends_with", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_ends_with ), ( "id_not_ends_with", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_not_ends_with ), ( "views", Encode.int |> Encode.optional input.views ), ( "views_not", Encode.int |> Encode.optional input.views_not ), ( "views_in", (Encode.int |> Encode.list) |> Encode.optional input.views_in ), ( "views_not_in", (Encode.int |> Encode.list) |> Encode.optional input.views_not_in ), ( "views_lt", Encode.int |> Encode.optional input.views_lt ), ( "views_lte", Encode.int |> Encode.optional input.views_lte ), ( "views_gt", Encode.int |> Encode.optional input.views_gt ), ( "views_gte", Encode.int |> Encode.optional input.views_gte ), ( "completed", Encode.int |> Encode.optional input.completed ), ( "completed_not", Encode.int |> Encode.optional input.completed_not ), ( "completed_in", (Encode.int |> Encode.list) |> Encode.optional input.completed_in ), ( "completed_not_in", (Encode.int |> Encode.list) |> Encode.optional input.completed_not_in ), ( "completed_lt", Encode.int |> Encode.optional input.completed_lt ), ( "completed_lte", Encode.int |> Encode.optional input.completed_lte ), ( "completed_gt", Encode.int |> Encode.optional input.completed_gt ), ( "completed_gte", Encode.int |> Encode.optional input.completed_gte ), ( "game", encodeGameWhereInput |> Encode.optional input.game ), ( "owner", encodeUserWhereInput |> Encode.optional input.owner ) ]


buildExerciseWhereUniqueInput : (ExerciseWhereUniqueInputOptionalFields -> ExerciseWhereUniqueInputOptionalFields) -> ExerciseWhereUniqueInput
buildExerciseWhereUniqueInput fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias ExerciseWhereUniqueInputOptionalFields =
    { id : OptionalArgument Api.Scalar.Id }


{-| Type for the ExerciseWhereUniqueInput input object.
-}
type alias ExerciseWhereUniqueInput =
    { id : OptionalArgument Api.Scalar.Id }


{-| Encode a ExerciseWhereUniqueInput into a value that can be used as an argument.
-}
encodeExerciseWhereUniqueInput : ExerciseWhereUniqueInput -> Value
encodeExerciseWhereUniqueInput input =
    Encode.maybeObject
        [ ( "id", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id ) ]


buildGameCreateInput : GameCreateInputRequiredFields -> GameCreateInput
buildGameCreateInput required =
    { name = required.name, description = required.description, slug = required.slug }


type alias GameCreateInputRequiredFields =
    { name : String, description : String, slug : String }


{-| Type for the GameCreateInput input object.
-}
type alias GameCreateInput =
    { name : String, description : String, slug : String }


{-| Encode a GameCreateInput into a value that can be used as an argument.
-}
encodeGameCreateInput : GameCreateInput -> Value
encodeGameCreateInput input =
    Encode.maybeObject
        [ ( "name", Encode.string input.name |> Just ), ( "description", Encode.string input.description |> Just ), ( "slug", Encode.string input.slug |> Just ) ]


buildGameCreateOneInput : (GameCreateOneInputOptionalFields -> GameCreateOneInputOptionalFields) -> GameCreateOneInput
buildGameCreateOneInput fillOptionals =
    let
        optionals =
            fillOptionals
                { create = Absent, connect = Absent }
    in
    { create = optionals.create, connect = optionals.connect }


type alias GameCreateOneInputOptionalFields =
    { create : OptionalArgument GameCreateInput, connect : OptionalArgument GameWhereUniqueInput }


{-| Type for the GameCreateOneInput input object.
-}
type alias GameCreateOneInput =
    { create : OptionalArgument GameCreateInput, connect : OptionalArgument GameWhereUniqueInput }


{-| Encode a GameCreateOneInput into a value that can be used as an argument.
-}
encodeGameCreateOneInput : GameCreateOneInput -> Value
encodeGameCreateOneInput input =
    Encode.maybeObject
        [ ( "create", encodeGameCreateInput |> Encode.optional input.create ), ( "connect", encodeGameWhereUniqueInput |> Encode.optional input.connect ) ]


buildGameSubscriptionWhereInput : (GameSubscriptionWhereInputOptionalFields -> GameSubscriptionWhereInputOptionalFields) -> GameSubscriptionWhereInput
buildGameSubscriptionWhereInput fillOptionals =
    let
        optionals =
            fillOptionals
                { and = Absent, or = Absent, not = Absent, mutation_in = Absent, updatedFields_contains = Absent, updatedFields_contains_every = Absent, updatedFields_contains_some = Absent, node = Absent }
    in
    GameSubscriptionWhereInput { and = optionals.and, or = optionals.or, not = optionals.not, mutation_in = optionals.mutation_in, updatedFields_contains = optionals.updatedFields_contains, updatedFields_contains_every = optionals.updatedFields_contains_every, updatedFields_contains_some = optionals.updatedFields_contains_some, node = optionals.node }


type alias GameSubscriptionWhereInputOptionalFields =
    { and : OptionalArgument (List GameSubscriptionWhereInput), or : OptionalArgument (List GameSubscriptionWhereInput), not : OptionalArgument (List GameSubscriptionWhereInput), mutation_in : OptionalArgument (List Api.Enum.MutationType.MutationType), updatedFields_contains : OptionalArgument String, updatedFields_contains_every : OptionalArgument (List String), updatedFields_contains_some : OptionalArgument (List String), node : OptionalArgument GameWhereInput }


{-| Type alias for the `GameSubscriptionWhereInput` attributes. Note that this type
needs to use the `GameSubscriptionWhereInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/graphqelm/issues/33>.
-}
type alias GameSubscriptionWhereInputRaw =
    { and : OptionalArgument (List GameSubscriptionWhereInput), or : OptionalArgument (List GameSubscriptionWhereInput), not : OptionalArgument (List GameSubscriptionWhereInput), mutation_in : OptionalArgument (List Api.Enum.MutationType.MutationType), updatedFields_contains : OptionalArgument String, updatedFields_contains_every : OptionalArgument (List String), updatedFields_contains_some : OptionalArgument (List String), node : OptionalArgument GameWhereInput }


{-| Type for the GameSubscriptionWhereInput input object.
-}
type GameSubscriptionWhereInput
    = GameSubscriptionWhereInput GameSubscriptionWhereInputRaw


{-| Encode a GameSubscriptionWhereInput into a value that can be used as an argument.
-}
encodeGameSubscriptionWhereInput : GameSubscriptionWhereInput -> Value
encodeGameSubscriptionWhereInput (GameSubscriptionWhereInput input) =
    Encode.maybeObject
        [ ( "AND", (encodeGameSubscriptionWhereInput |> Encode.list) |> Encode.optional input.and ), ( "OR", (encodeGameSubscriptionWhereInput |> Encode.list) |> Encode.optional input.or ), ( "NOT", (encodeGameSubscriptionWhereInput |> Encode.list) |> Encode.optional input.not ), ( "mutation_in", (Encode.enum Api.Enum.MutationType.toString |> Encode.list) |> Encode.optional input.mutation_in ), ( "updatedFields_contains", Encode.string |> Encode.optional input.updatedFields_contains ), ( "updatedFields_contains_every", (Encode.string |> Encode.list) |> Encode.optional input.updatedFields_contains_every ), ( "updatedFields_contains_some", (Encode.string |> Encode.list) |> Encode.optional input.updatedFields_contains_some ), ( "node", encodeGameWhereInput |> Encode.optional input.node ) ]


buildGameUpdateDataInput : (GameUpdateDataInputOptionalFields -> GameUpdateDataInputOptionalFields) -> GameUpdateDataInput
buildGameUpdateDataInput fillOptionals =
    let
        optionals =
            fillOptionals
                { name = Absent, description = Absent, slug = Absent }
    in
    { name = optionals.name, description = optionals.description, slug = optionals.slug }


type alias GameUpdateDataInputOptionalFields =
    { name : OptionalArgument String, description : OptionalArgument String, slug : OptionalArgument String }


{-| Type for the GameUpdateDataInput input object.
-}
type alias GameUpdateDataInput =
    { name : OptionalArgument String, description : OptionalArgument String, slug : OptionalArgument String }


{-| Encode a GameUpdateDataInput into a value that can be used as an argument.
-}
encodeGameUpdateDataInput : GameUpdateDataInput -> Value
encodeGameUpdateDataInput input =
    Encode.maybeObject
        [ ( "name", Encode.string |> Encode.optional input.name ), ( "description", Encode.string |> Encode.optional input.description ), ( "slug", Encode.string |> Encode.optional input.slug ) ]


buildGameUpdateInput : (GameUpdateInputOptionalFields -> GameUpdateInputOptionalFields) -> GameUpdateInput
buildGameUpdateInput fillOptionals =
    let
        optionals =
            fillOptionals
                { name = Absent, description = Absent, slug = Absent }
    in
    { name = optionals.name, description = optionals.description, slug = optionals.slug }


type alias GameUpdateInputOptionalFields =
    { name : OptionalArgument String, description : OptionalArgument String, slug : OptionalArgument String }


{-| Type for the GameUpdateInput input object.
-}
type alias GameUpdateInput =
    { name : OptionalArgument String, description : OptionalArgument String, slug : OptionalArgument String }


{-| Encode a GameUpdateInput into a value that can be used as an argument.
-}
encodeGameUpdateInput : GameUpdateInput -> Value
encodeGameUpdateInput input =
    Encode.maybeObject
        [ ( "name", Encode.string |> Encode.optional input.name ), ( "description", Encode.string |> Encode.optional input.description ), ( "slug", Encode.string |> Encode.optional input.slug ) ]


buildGameUpdateOneInput : (GameUpdateOneInputOptionalFields -> GameUpdateOneInputOptionalFields) -> GameUpdateOneInput
buildGameUpdateOneInput fillOptionals =
    let
        optionals =
            fillOptionals
                { create = Absent, connect = Absent, delete = Absent, update = Absent, upsert = Absent }
    in
    { create = optionals.create, connect = optionals.connect, delete = optionals.delete, update = optionals.update, upsert = optionals.upsert }


type alias GameUpdateOneInputOptionalFields =
    { create : OptionalArgument GameCreateInput, connect : OptionalArgument GameWhereUniqueInput, delete : OptionalArgument Bool, update : OptionalArgument GameUpdateDataInput, upsert : OptionalArgument GameUpsertNestedInput }


{-| Type for the GameUpdateOneInput input object.
-}
type alias GameUpdateOneInput =
    { create : OptionalArgument GameCreateInput, connect : OptionalArgument GameWhereUniqueInput, delete : OptionalArgument Bool, update : OptionalArgument GameUpdateDataInput, upsert : OptionalArgument GameUpsertNestedInput }


{-| Encode a GameUpdateOneInput into a value that can be used as an argument.
-}
encodeGameUpdateOneInput : GameUpdateOneInput -> Value
encodeGameUpdateOneInput input =
    Encode.maybeObject
        [ ( "create", encodeGameCreateInput |> Encode.optional input.create ), ( "connect", encodeGameWhereUniqueInput |> Encode.optional input.connect ), ( "delete", Encode.bool |> Encode.optional input.delete ), ( "update", encodeGameUpdateDataInput |> Encode.optional input.update ), ( "upsert", encodeGameUpsertNestedInput |> Encode.optional input.upsert ) ]


buildGameUpsertNestedInput : GameUpsertNestedInputRequiredFields -> GameUpsertNestedInput
buildGameUpsertNestedInput required =
    { update = required.update, create = required.create }


type alias GameUpsertNestedInputRequiredFields =
    { update : GameUpdateDataInput, create : GameCreateInput }


{-| Type for the GameUpsertNestedInput input object.
-}
type alias GameUpsertNestedInput =
    { update : GameUpdateDataInput, create : GameCreateInput }


{-| Encode a GameUpsertNestedInput into a value that can be used as an argument.
-}
encodeGameUpsertNestedInput : GameUpsertNestedInput -> Value
encodeGameUpsertNestedInput input =
    Encode.maybeObject
        [ ( "update", encodeGameUpdateDataInput input.update |> Just ), ( "create", encodeGameCreateInput input.create |> Just ) ]


buildGameWhereInput : (GameWhereInputOptionalFields -> GameWhereInputOptionalFields) -> GameWhereInput
buildGameWhereInput fillOptionals =
    let
        optionals =
            fillOptionals
                { and = Absent, or = Absent, not = Absent, id = Absent, id_not = Absent, id_in = Absent, id_not_in = Absent, id_lt = Absent, id_lte = Absent, id_gt = Absent, id_gte = Absent, id_contains = Absent, id_not_contains = Absent, id_starts_with = Absent, id_not_starts_with = Absent, id_ends_with = Absent, id_not_ends_with = Absent, createdAt = Absent, createdAt_not = Absent, createdAt_in = Absent, createdAt_not_in = Absent, createdAt_lt = Absent, createdAt_lte = Absent, createdAt_gt = Absent, createdAt_gte = Absent, name = Absent, name_not = Absent, name_in = Absent, name_not_in = Absent, name_lt = Absent, name_lte = Absent, name_gt = Absent, name_gte = Absent, name_contains = Absent, name_not_contains = Absent, name_starts_with = Absent, name_not_starts_with = Absent, name_ends_with = Absent, name_not_ends_with = Absent, description = Absent, description_not = Absent, description_in = Absent, description_not_in = Absent, description_lt = Absent, description_lte = Absent, description_gt = Absent, description_gte = Absent, description_contains = Absent, description_not_contains = Absent, description_starts_with = Absent, description_not_starts_with = Absent, description_ends_with = Absent, description_not_ends_with = Absent, slug = Absent, slug_not = Absent, slug_in = Absent, slug_not_in = Absent, slug_lt = Absent, slug_lte = Absent, slug_gt = Absent, slug_gte = Absent, slug_contains = Absent, slug_not_contains = Absent, slug_starts_with = Absent, slug_not_starts_with = Absent, slug_ends_with = Absent, slug_not_ends_with = Absent }
    in
    GameWhereInput { and = optionals.and, or = optionals.or, not = optionals.not, id = optionals.id, id_not = optionals.id_not, id_in = optionals.id_in, id_not_in = optionals.id_not_in, id_lt = optionals.id_lt, id_lte = optionals.id_lte, id_gt = optionals.id_gt, id_gte = optionals.id_gte, id_contains = optionals.id_contains, id_not_contains = optionals.id_not_contains, id_starts_with = optionals.id_starts_with, id_not_starts_with = optionals.id_not_starts_with, id_ends_with = optionals.id_ends_with, id_not_ends_with = optionals.id_not_ends_with, createdAt = optionals.createdAt, createdAt_not = optionals.createdAt_not, createdAt_in = optionals.createdAt_in, createdAt_not_in = optionals.createdAt_not_in, createdAt_lt = optionals.createdAt_lt, createdAt_lte = optionals.createdAt_lte, createdAt_gt = optionals.createdAt_gt, createdAt_gte = optionals.createdAt_gte, name = optionals.name, name_not = optionals.name_not, name_in = optionals.name_in, name_not_in = optionals.name_not_in, name_lt = optionals.name_lt, name_lte = optionals.name_lte, name_gt = optionals.name_gt, name_gte = optionals.name_gte, name_contains = optionals.name_contains, name_not_contains = optionals.name_not_contains, name_starts_with = optionals.name_starts_with, name_not_starts_with = optionals.name_not_starts_with, name_ends_with = optionals.name_ends_with, name_not_ends_with = optionals.name_not_ends_with, description = optionals.description, description_not = optionals.description_not, description_in = optionals.description_in, description_not_in = optionals.description_not_in, description_lt = optionals.description_lt, description_lte = optionals.description_lte, description_gt = optionals.description_gt, description_gte = optionals.description_gte, description_contains = optionals.description_contains, description_not_contains = optionals.description_not_contains, description_starts_with = optionals.description_starts_with, description_not_starts_with = optionals.description_not_starts_with, description_ends_with = optionals.description_ends_with, description_not_ends_with = optionals.description_not_ends_with, slug = optionals.slug, slug_not = optionals.slug_not, slug_in = optionals.slug_in, slug_not_in = optionals.slug_not_in, slug_lt = optionals.slug_lt, slug_lte = optionals.slug_lte, slug_gt = optionals.slug_gt, slug_gte = optionals.slug_gte, slug_contains = optionals.slug_contains, slug_not_contains = optionals.slug_not_contains, slug_starts_with = optionals.slug_starts_with, slug_not_starts_with = optionals.slug_not_starts_with, slug_ends_with = optionals.slug_ends_with, slug_not_ends_with = optionals.slug_not_ends_with }


type alias GameWhereInputOptionalFields =
    { and : OptionalArgument (List GameWhereInput), or : OptionalArgument (List GameWhereInput), not : OptionalArgument (List GameWhereInput), id : OptionalArgument Api.Scalar.Id, id_not : OptionalArgument Api.Scalar.Id, id_in : OptionalArgument (List Api.Scalar.Id), id_not_in : OptionalArgument (List Api.Scalar.Id), id_lt : OptionalArgument Api.Scalar.Id, id_lte : OptionalArgument Api.Scalar.Id, id_gt : OptionalArgument Api.Scalar.Id, id_gte : OptionalArgument Api.Scalar.Id, id_contains : OptionalArgument Api.Scalar.Id, id_not_contains : OptionalArgument Api.Scalar.Id, id_starts_with : OptionalArgument Api.Scalar.Id, id_not_starts_with : OptionalArgument Api.Scalar.Id, id_ends_with : OptionalArgument Api.Scalar.Id, id_not_ends_with : OptionalArgument Api.Scalar.Id, createdAt : OptionalArgument Api.Scalar.DateTime, createdAt_not : OptionalArgument Api.Scalar.DateTime, createdAt_in : OptionalArgument (List Api.Scalar.DateTime), createdAt_not_in : OptionalArgument (List Api.Scalar.DateTime), createdAt_lt : OptionalArgument Api.Scalar.DateTime, createdAt_lte : OptionalArgument Api.Scalar.DateTime, createdAt_gt : OptionalArgument Api.Scalar.DateTime, createdAt_gte : OptionalArgument Api.Scalar.DateTime, name : OptionalArgument String, name_not : OptionalArgument String, name_in : OptionalArgument (List String), name_not_in : OptionalArgument (List String), name_lt : OptionalArgument String, name_lte : OptionalArgument String, name_gt : OptionalArgument String, name_gte : OptionalArgument String, name_contains : OptionalArgument String, name_not_contains : OptionalArgument String, name_starts_with : OptionalArgument String, name_not_starts_with : OptionalArgument String, name_ends_with : OptionalArgument String, name_not_ends_with : OptionalArgument String, description : OptionalArgument String, description_not : OptionalArgument String, description_in : OptionalArgument (List String), description_not_in : OptionalArgument (List String), description_lt : OptionalArgument String, description_lte : OptionalArgument String, description_gt : OptionalArgument String, description_gte : OptionalArgument String, description_contains : OptionalArgument String, description_not_contains : OptionalArgument String, description_starts_with : OptionalArgument String, description_not_starts_with : OptionalArgument String, description_ends_with : OptionalArgument String, description_not_ends_with : OptionalArgument String, slug : OptionalArgument String, slug_not : OptionalArgument String, slug_in : OptionalArgument (List String), slug_not_in : OptionalArgument (List String), slug_lt : OptionalArgument String, slug_lte : OptionalArgument String, slug_gt : OptionalArgument String, slug_gte : OptionalArgument String, slug_contains : OptionalArgument String, slug_not_contains : OptionalArgument String, slug_starts_with : OptionalArgument String, slug_not_starts_with : OptionalArgument String, slug_ends_with : OptionalArgument String, slug_not_ends_with : OptionalArgument String }


{-| Type alias for the `GameWhereInput` attributes. Note that this type
needs to use the `GameWhereInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/graphqelm/issues/33>.
-}
type alias GameWhereInputRaw =
    { and : OptionalArgument (List GameWhereInput), or : OptionalArgument (List GameWhereInput), not : OptionalArgument (List GameWhereInput), id : OptionalArgument Api.Scalar.Id, id_not : OptionalArgument Api.Scalar.Id, id_in : OptionalArgument (List Api.Scalar.Id), id_not_in : OptionalArgument (List Api.Scalar.Id), id_lt : OptionalArgument Api.Scalar.Id, id_lte : OptionalArgument Api.Scalar.Id, id_gt : OptionalArgument Api.Scalar.Id, id_gte : OptionalArgument Api.Scalar.Id, id_contains : OptionalArgument Api.Scalar.Id, id_not_contains : OptionalArgument Api.Scalar.Id, id_starts_with : OptionalArgument Api.Scalar.Id, id_not_starts_with : OptionalArgument Api.Scalar.Id, id_ends_with : OptionalArgument Api.Scalar.Id, id_not_ends_with : OptionalArgument Api.Scalar.Id, createdAt : OptionalArgument Api.Scalar.DateTime, createdAt_not : OptionalArgument Api.Scalar.DateTime, createdAt_in : OptionalArgument (List Api.Scalar.DateTime), createdAt_not_in : OptionalArgument (List Api.Scalar.DateTime), createdAt_lt : OptionalArgument Api.Scalar.DateTime, createdAt_lte : OptionalArgument Api.Scalar.DateTime, createdAt_gt : OptionalArgument Api.Scalar.DateTime, createdAt_gte : OptionalArgument Api.Scalar.DateTime, name : OptionalArgument String, name_not : OptionalArgument String, name_in : OptionalArgument (List String), name_not_in : OptionalArgument (List String), name_lt : OptionalArgument String, name_lte : OptionalArgument String, name_gt : OptionalArgument String, name_gte : OptionalArgument String, name_contains : OptionalArgument String, name_not_contains : OptionalArgument String, name_starts_with : OptionalArgument String, name_not_starts_with : OptionalArgument String, name_ends_with : OptionalArgument String, name_not_ends_with : OptionalArgument String, description : OptionalArgument String, description_not : OptionalArgument String, description_in : OptionalArgument (List String), description_not_in : OptionalArgument (List String), description_lt : OptionalArgument String, description_lte : OptionalArgument String, description_gt : OptionalArgument String, description_gte : OptionalArgument String, description_contains : OptionalArgument String, description_not_contains : OptionalArgument String, description_starts_with : OptionalArgument String, description_not_starts_with : OptionalArgument String, description_ends_with : OptionalArgument String, description_not_ends_with : OptionalArgument String, slug : OptionalArgument String, slug_not : OptionalArgument String, slug_in : OptionalArgument (List String), slug_not_in : OptionalArgument (List String), slug_lt : OptionalArgument String, slug_lte : OptionalArgument String, slug_gt : OptionalArgument String, slug_gte : OptionalArgument String, slug_contains : OptionalArgument String, slug_not_contains : OptionalArgument String, slug_starts_with : OptionalArgument String, slug_not_starts_with : OptionalArgument String, slug_ends_with : OptionalArgument String, slug_not_ends_with : OptionalArgument String }


{-| Type for the GameWhereInput input object.
-}
type GameWhereInput
    = GameWhereInput GameWhereInputRaw


{-| Encode a GameWhereInput into a value that can be used as an argument.
-}
encodeGameWhereInput : GameWhereInput -> Value
encodeGameWhereInput (GameWhereInput input) =
    Encode.maybeObject
        [ ( "AND", (encodeGameWhereInput |> Encode.list) |> Encode.optional input.and ), ( "OR", (encodeGameWhereInput |> Encode.list) |> Encode.optional input.or ), ( "NOT", (encodeGameWhereInput |> Encode.list) |> Encode.optional input.not ), ( "id", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id ), ( "id_not", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_not ), ( "id_in", ((\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.list) |> Encode.optional input.id_in ), ( "id_not_in", ((\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.list) |> Encode.optional input.id_not_in ), ( "id_lt", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_lt ), ( "id_lte", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_lte ), ( "id_gt", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_gt ), ( "id_gte", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_gte ), ( "id_contains", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_contains ), ( "id_not_contains", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_not_contains ), ( "id_starts_with", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_starts_with ), ( "id_not_starts_with", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_not_starts_with ), ( "id_ends_with", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_ends_with ), ( "id_not_ends_with", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_not_ends_with ), ( "createdAt", (\(Api.Scalar.DateTime raw) -> Encode.string raw) |> Encode.optional input.createdAt ), ( "createdAt_not", (\(Api.Scalar.DateTime raw) -> Encode.string raw) |> Encode.optional input.createdAt_not ), ( "createdAt_in", ((\(Api.Scalar.DateTime raw) -> Encode.string raw) |> Encode.list) |> Encode.optional input.createdAt_in ), ( "createdAt_not_in", ((\(Api.Scalar.DateTime raw) -> Encode.string raw) |> Encode.list) |> Encode.optional input.createdAt_not_in ), ( "createdAt_lt", (\(Api.Scalar.DateTime raw) -> Encode.string raw) |> Encode.optional input.createdAt_lt ), ( "createdAt_lte", (\(Api.Scalar.DateTime raw) -> Encode.string raw) |> Encode.optional input.createdAt_lte ), ( "createdAt_gt", (\(Api.Scalar.DateTime raw) -> Encode.string raw) |> Encode.optional input.createdAt_gt ), ( "createdAt_gte", (\(Api.Scalar.DateTime raw) -> Encode.string raw) |> Encode.optional input.createdAt_gte ), ( "name", Encode.string |> Encode.optional input.name ), ( "name_not", Encode.string |> Encode.optional input.name_not ), ( "name_in", (Encode.string |> Encode.list) |> Encode.optional input.name_in ), ( "name_not_in", (Encode.string |> Encode.list) |> Encode.optional input.name_not_in ), ( "name_lt", Encode.string |> Encode.optional input.name_lt ), ( "name_lte", Encode.string |> Encode.optional input.name_lte ), ( "name_gt", Encode.string |> Encode.optional input.name_gt ), ( "name_gte", Encode.string |> Encode.optional input.name_gte ), ( "name_contains", Encode.string |> Encode.optional input.name_contains ), ( "name_not_contains", Encode.string |> Encode.optional input.name_not_contains ), ( "name_starts_with", Encode.string |> Encode.optional input.name_starts_with ), ( "name_not_starts_with", Encode.string |> Encode.optional input.name_not_starts_with ), ( "name_ends_with", Encode.string |> Encode.optional input.name_ends_with ), ( "name_not_ends_with", Encode.string |> Encode.optional input.name_not_ends_with ), ( "description", Encode.string |> Encode.optional input.description ), ( "description_not", Encode.string |> Encode.optional input.description_not ), ( "description_in", (Encode.string |> Encode.list) |> Encode.optional input.description_in ), ( "description_not_in", (Encode.string |> Encode.list) |> Encode.optional input.description_not_in ), ( "description_lt", Encode.string |> Encode.optional input.description_lt ), ( "description_lte", Encode.string |> Encode.optional input.description_lte ), ( "description_gt", Encode.string |> Encode.optional input.description_gt ), ( "description_gte", Encode.string |> Encode.optional input.description_gte ), ( "description_contains", Encode.string |> Encode.optional input.description_contains ), ( "description_not_contains", Encode.string |> Encode.optional input.description_not_contains ), ( "description_starts_with", Encode.string |> Encode.optional input.description_starts_with ), ( "description_not_starts_with", Encode.string |> Encode.optional input.description_not_starts_with ), ( "description_ends_with", Encode.string |> Encode.optional input.description_ends_with ), ( "description_not_ends_with", Encode.string |> Encode.optional input.description_not_ends_with ), ( "slug", Encode.string |> Encode.optional input.slug ), ( "slug_not", Encode.string |> Encode.optional input.slug_not ), ( "slug_in", (Encode.string |> Encode.list) |> Encode.optional input.slug_in ), ( "slug_not_in", (Encode.string |> Encode.list) |> Encode.optional input.slug_not_in ), ( "slug_lt", Encode.string |> Encode.optional input.slug_lt ), ( "slug_lte", Encode.string |> Encode.optional input.slug_lte ), ( "slug_gt", Encode.string |> Encode.optional input.slug_gt ), ( "slug_gte", Encode.string |> Encode.optional input.slug_gte ), ( "slug_contains", Encode.string |> Encode.optional input.slug_contains ), ( "slug_not_contains", Encode.string |> Encode.optional input.slug_not_contains ), ( "slug_starts_with", Encode.string |> Encode.optional input.slug_starts_with ), ( "slug_not_starts_with", Encode.string |> Encode.optional input.slug_not_starts_with ), ( "slug_ends_with", Encode.string |> Encode.optional input.slug_ends_with ), ( "slug_not_ends_with", Encode.string |> Encode.optional input.slug_not_ends_with ) ]


buildGameWhereUniqueInput : (GameWhereUniqueInputOptionalFields -> GameWhereUniqueInputOptionalFields) -> GameWhereUniqueInput
buildGameWhereUniqueInput fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, slug = Absent }
    in
    { id = optionals.id, slug = optionals.slug }


type alias GameWhereUniqueInputOptionalFields =
    { id : OptionalArgument Api.Scalar.Id, slug : OptionalArgument String }


{-| Type for the GameWhereUniqueInput input object.
-}
type alias GameWhereUniqueInput =
    { id : OptionalArgument Api.Scalar.Id, slug : OptionalArgument String }


{-| Encode a GameWhereUniqueInput into a value that can be used as an argument.
-}
encodeGameWhereUniqueInput : GameWhereUniqueInput -> Value
encodeGameWhereUniqueInput input =
    Encode.maybeObject
        [ ( "id", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id ), ( "slug", Encode.string |> Encode.optional input.slug ) ]


buildUserCreateInput : UserCreateInputRequiredFields -> (UserCreateInputOptionalFields -> UserCreateInputOptionalFields) -> UserCreateInput
buildUserCreateInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { exercises = Absent }
    in
    UserCreateInput { name = required.name, email = required.email, password = required.password, exercises = optionals.exercises }


type alias UserCreateInputRequiredFields =
    { name : String, email : String, password : String }


type alias UserCreateInputOptionalFields =
    { exercises : OptionalArgument ExerciseCreateManyWithoutOwnerInput }


{-| Type alias for the `UserCreateInput` attributes. Note that this type
needs to use the `UserCreateInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/graphqelm/issues/33>.
-}
type alias UserCreateInputRaw =
    { name : String, email : String, password : String, exercises : OptionalArgument ExerciseCreateManyWithoutOwnerInput }


{-| Type for the UserCreateInput input object.
-}
type UserCreateInput
    = UserCreateInput UserCreateInputRaw


{-| Encode a UserCreateInput into a value that can be used as an argument.
-}
encodeUserCreateInput : UserCreateInput -> Value
encodeUserCreateInput (UserCreateInput input) =
    Encode.maybeObject
        [ ( "name", Encode.string input.name |> Just ), ( "email", Encode.string input.email |> Just ), ( "password", Encode.string input.password |> Just ), ( "exercises", encodeExerciseCreateManyWithoutOwnerInput |> Encode.optional input.exercises ) ]


buildUserCreateOneWithoutExercisesInput : (UserCreateOneWithoutExercisesInputOptionalFields -> UserCreateOneWithoutExercisesInputOptionalFields) -> UserCreateOneWithoutExercisesInput
buildUserCreateOneWithoutExercisesInput fillOptionals =
    let
        optionals =
            fillOptionals
                { create = Absent, connect = Absent }
    in
    { create = optionals.create, connect = optionals.connect }


type alias UserCreateOneWithoutExercisesInputOptionalFields =
    { create : OptionalArgument UserCreateWithoutExercisesInput, connect : OptionalArgument UserWhereUniqueInput }


{-| Type for the UserCreateOneWithoutExercisesInput input object.
-}
type alias UserCreateOneWithoutExercisesInput =
    { create : OptionalArgument UserCreateWithoutExercisesInput, connect : OptionalArgument UserWhereUniqueInput }


{-| Encode a UserCreateOneWithoutExercisesInput into a value that can be used as an argument.
-}
encodeUserCreateOneWithoutExercisesInput : UserCreateOneWithoutExercisesInput -> Value
encodeUserCreateOneWithoutExercisesInput input =
    Encode.maybeObject
        [ ( "create", encodeUserCreateWithoutExercisesInput |> Encode.optional input.create ), ( "connect", encodeUserWhereUniqueInput |> Encode.optional input.connect ) ]


buildUserCreateWithoutExercisesInput : UserCreateWithoutExercisesInputRequiredFields -> UserCreateWithoutExercisesInput
buildUserCreateWithoutExercisesInput required =
    { name = required.name, email = required.email, password = required.password }


type alias UserCreateWithoutExercisesInputRequiredFields =
    { name : String, email : String, password : String }


{-| Type for the UserCreateWithoutExercisesInput input object.
-}
type alias UserCreateWithoutExercisesInput =
    { name : String, email : String, password : String }


{-| Encode a UserCreateWithoutExercisesInput into a value that can be used as an argument.
-}
encodeUserCreateWithoutExercisesInput : UserCreateWithoutExercisesInput -> Value
encodeUserCreateWithoutExercisesInput input =
    Encode.maybeObject
        [ ( "name", Encode.string input.name |> Just ), ( "email", Encode.string input.email |> Just ), ( "password", Encode.string input.password |> Just ) ]


buildUserSubscriptionWhereInput : (UserSubscriptionWhereInputOptionalFields -> UserSubscriptionWhereInputOptionalFields) -> UserSubscriptionWhereInput
buildUserSubscriptionWhereInput fillOptionals =
    let
        optionals =
            fillOptionals
                { and = Absent, or = Absent, not = Absent, mutation_in = Absent, updatedFields_contains = Absent, updatedFields_contains_every = Absent, updatedFields_contains_some = Absent, node = Absent }
    in
    UserSubscriptionWhereInput { and = optionals.and, or = optionals.or, not = optionals.not, mutation_in = optionals.mutation_in, updatedFields_contains = optionals.updatedFields_contains, updatedFields_contains_every = optionals.updatedFields_contains_every, updatedFields_contains_some = optionals.updatedFields_contains_some, node = optionals.node }


type alias UserSubscriptionWhereInputOptionalFields =
    { and : OptionalArgument (List UserSubscriptionWhereInput), or : OptionalArgument (List UserSubscriptionWhereInput), not : OptionalArgument (List UserSubscriptionWhereInput), mutation_in : OptionalArgument (List Api.Enum.MutationType.MutationType), updatedFields_contains : OptionalArgument String, updatedFields_contains_every : OptionalArgument (List String), updatedFields_contains_some : OptionalArgument (List String), node : OptionalArgument UserWhereInput }


{-| Type alias for the `UserSubscriptionWhereInput` attributes. Note that this type
needs to use the `UserSubscriptionWhereInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/graphqelm/issues/33>.
-}
type alias UserSubscriptionWhereInputRaw =
    { and : OptionalArgument (List UserSubscriptionWhereInput), or : OptionalArgument (List UserSubscriptionWhereInput), not : OptionalArgument (List UserSubscriptionWhereInput), mutation_in : OptionalArgument (List Api.Enum.MutationType.MutationType), updatedFields_contains : OptionalArgument String, updatedFields_contains_every : OptionalArgument (List String), updatedFields_contains_some : OptionalArgument (List String), node : OptionalArgument UserWhereInput }


{-| Type for the UserSubscriptionWhereInput input object.
-}
type UserSubscriptionWhereInput
    = UserSubscriptionWhereInput UserSubscriptionWhereInputRaw


{-| Encode a UserSubscriptionWhereInput into a value that can be used as an argument.
-}
encodeUserSubscriptionWhereInput : UserSubscriptionWhereInput -> Value
encodeUserSubscriptionWhereInput (UserSubscriptionWhereInput input) =
    Encode.maybeObject
        [ ( "AND", (encodeUserSubscriptionWhereInput |> Encode.list) |> Encode.optional input.and ), ( "OR", (encodeUserSubscriptionWhereInput |> Encode.list) |> Encode.optional input.or ), ( "NOT", (encodeUserSubscriptionWhereInput |> Encode.list) |> Encode.optional input.not ), ( "mutation_in", (Encode.enum Api.Enum.MutationType.toString |> Encode.list) |> Encode.optional input.mutation_in ), ( "updatedFields_contains", Encode.string |> Encode.optional input.updatedFields_contains ), ( "updatedFields_contains_every", (Encode.string |> Encode.list) |> Encode.optional input.updatedFields_contains_every ), ( "updatedFields_contains_some", (Encode.string |> Encode.list) |> Encode.optional input.updatedFields_contains_some ), ( "node", encodeUserWhereInput |> Encode.optional input.node ) ]


buildUserUpdateInput : (UserUpdateInputOptionalFields -> UserUpdateInputOptionalFields) -> UserUpdateInput
buildUserUpdateInput fillOptionals =
    let
        optionals =
            fillOptionals
                { name = Absent, email = Absent, password = Absent, exercises = Absent }
    in
    UserUpdateInput { name = optionals.name, email = optionals.email, password = optionals.password, exercises = optionals.exercises }


type alias UserUpdateInputOptionalFields =
    { name : OptionalArgument String, email : OptionalArgument String, password : OptionalArgument String, exercises : OptionalArgument ExerciseUpdateManyWithoutOwnerInput }


{-| Type alias for the `UserUpdateInput` attributes. Note that this type
needs to use the `UserUpdateInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/graphqelm/issues/33>.
-}
type alias UserUpdateInputRaw =
    { name : OptionalArgument String, email : OptionalArgument String, password : OptionalArgument String, exercises : OptionalArgument ExerciseUpdateManyWithoutOwnerInput }


{-| Type for the UserUpdateInput input object.
-}
type UserUpdateInput
    = UserUpdateInput UserUpdateInputRaw


{-| Encode a UserUpdateInput into a value that can be used as an argument.
-}
encodeUserUpdateInput : UserUpdateInput -> Value
encodeUserUpdateInput (UserUpdateInput input) =
    Encode.maybeObject
        [ ( "name", Encode.string |> Encode.optional input.name ), ( "email", Encode.string |> Encode.optional input.email ), ( "password", Encode.string |> Encode.optional input.password ), ( "exercises", encodeExerciseUpdateManyWithoutOwnerInput |> Encode.optional input.exercises ) ]


buildUserUpdateOneWithoutExercisesInput : (UserUpdateOneWithoutExercisesInputOptionalFields -> UserUpdateOneWithoutExercisesInputOptionalFields) -> UserUpdateOneWithoutExercisesInput
buildUserUpdateOneWithoutExercisesInput fillOptionals =
    let
        optionals =
            fillOptionals
                { create = Absent, connect = Absent, delete = Absent, update = Absent, upsert = Absent }
    in
    { create = optionals.create, connect = optionals.connect, delete = optionals.delete, update = optionals.update, upsert = optionals.upsert }


type alias UserUpdateOneWithoutExercisesInputOptionalFields =
    { create : OptionalArgument UserCreateWithoutExercisesInput, connect : OptionalArgument UserWhereUniqueInput, delete : OptionalArgument Bool, update : OptionalArgument UserUpdateWithoutExercisesDataInput, upsert : OptionalArgument UserUpsertWithoutExercisesInput }


{-| Type for the UserUpdateOneWithoutExercisesInput input object.
-}
type alias UserUpdateOneWithoutExercisesInput =
    { create : OptionalArgument UserCreateWithoutExercisesInput, connect : OptionalArgument UserWhereUniqueInput, delete : OptionalArgument Bool, update : OptionalArgument UserUpdateWithoutExercisesDataInput, upsert : OptionalArgument UserUpsertWithoutExercisesInput }


{-| Encode a UserUpdateOneWithoutExercisesInput into a value that can be used as an argument.
-}
encodeUserUpdateOneWithoutExercisesInput : UserUpdateOneWithoutExercisesInput -> Value
encodeUserUpdateOneWithoutExercisesInput input =
    Encode.maybeObject
        [ ( "create", encodeUserCreateWithoutExercisesInput |> Encode.optional input.create ), ( "connect", encodeUserWhereUniqueInput |> Encode.optional input.connect ), ( "delete", Encode.bool |> Encode.optional input.delete ), ( "update", encodeUserUpdateWithoutExercisesDataInput |> Encode.optional input.update ), ( "upsert", encodeUserUpsertWithoutExercisesInput |> Encode.optional input.upsert ) ]


buildUserUpdateWithoutExercisesDataInput : (UserUpdateWithoutExercisesDataInputOptionalFields -> UserUpdateWithoutExercisesDataInputOptionalFields) -> UserUpdateWithoutExercisesDataInput
buildUserUpdateWithoutExercisesDataInput fillOptionals =
    let
        optionals =
            fillOptionals
                { name = Absent, email = Absent, password = Absent }
    in
    { name = optionals.name, email = optionals.email, password = optionals.password }


type alias UserUpdateWithoutExercisesDataInputOptionalFields =
    { name : OptionalArgument String, email : OptionalArgument String, password : OptionalArgument String }


{-| Type for the UserUpdateWithoutExercisesDataInput input object.
-}
type alias UserUpdateWithoutExercisesDataInput =
    { name : OptionalArgument String, email : OptionalArgument String, password : OptionalArgument String }


{-| Encode a UserUpdateWithoutExercisesDataInput into a value that can be used as an argument.
-}
encodeUserUpdateWithoutExercisesDataInput : UserUpdateWithoutExercisesDataInput -> Value
encodeUserUpdateWithoutExercisesDataInput input =
    Encode.maybeObject
        [ ( "name", Encode.string |> Encode.optional input.name ), ( "email", Encode.string |> Encode.optional input.email ), ( "password", Encode.string |> Encode.optional input.password ) ]


buildUserUpsertWithoutExercisesInput : UserUpsertWithoutExercisesInputRequiredFields -> UserUpsertWithoutExercisesInput
buildUserUpsertWithoutExercisesInput required =
    { update = required.update, create = required.create }


type alias UserUpsertWithoutExercisesInputRequiredFields =
    { update : UserUpdateWithoutExercisesDataInput, create : UserCreateWithoutExercisesInput }


{-| Type for the UserUpsertWithoutExercisesInput input object.
-}
type alias UserUpsertWithoutExercisesInput =
    { update : UserUpdateWithoutExercisesDataInput, create : UserCreateWithoutExercisesInput }


{-| Encode a UserUpsertWithoutExercisesInput into a value that can be used as an argument.
-}
encodeUserUpsertWithoutExercisesInput : UserUpsertWithoutExercisesInput -> Value
encodeUserUpsertWithoutExercisesInput input =
    Encode.maybeObject
        [ ( "update", encodeUserUpdateWithoutExercisesDataInput input.update |> Just ), ( "create", encodeUserCreateWithoutExercisesInput input.create |> Just ) ]


buildUserWhereInput : (UserWhereInputOptionalFields -> UserWhereInputOptionalFields) -> UserWhereInput
buildUserWhereInput fillOptionals =
    let
        optionals =
            fillOptionals
                { and = Absent, or = Absent, not = Absent, id = Absent, id_not = Absent, id_in = Absent, id_not_in = Absent, id_lt = Absent, id_lte = Absent, id_gt = Absent, id_gte = Absent, id_contains = Absent, id_not_contains = Absent, id_starts_with = Absent, id_not_starts_with = Absent, id_ends_with = Absent, id_not_ends_with = Absent, name = Absent, name_not = Absent, name_in = Absent, name_not_in = Absent, name_lt = Absent, name_lte = Absent, name_gt = Absent, name_gte = Absent, name_contains = Absent, name_not_contains = Absent, name_starts_with = Absent, name_not_starts_with = Absent, name_ends_with = Absent, name_not_ends_with = Absent, email = Absent, email_not = Absent, email_in = Absent, email_not_in = Absent, email_lt = Absent, email_lte = Absent, email_gt = Absent, email_gte = Absent, email_contains = Absent, email_not_contains = Absent, email_starts_with = Absent, email_not_starts_with = Absent, email_ends_with = Absent, email_not_ends_with = Absent, password = Absent, password_not = Absent, password_in = Absent, password_not_in = Absent, password_lt = Absent, password_lte = Absent, password_gt = Absent, password_gte = Absent, password_contains = Absent, password_not_contains = Absent, password_starts_with = Absent, password_not_starts_with = Absent, password_ends_with = Absent, password_not_ends_with = Absent, exercises_every = Absent, exercises_some = Absent, exercises_none = Absent }
    in
    UserWhereInput { and = optionals.and, or = optionals.or, not = optionals.not, id = optionals.id, id_not = optionals.id_not, id_in = optionals.id_in, id_not_in = optionals.id_not_in, id_lt = optionals.id_lt, id_lte = optionals.id_lte, id_gt = optionals.id_gt, id_gte = optionals.id_gte, id_contains = optionals.id_contains, id_not_contains = optionals.id_not_contains, id_starts_with = optionals.id_starts_with, id_not_starts_with = optionals.id_not_starts_with, id_ends_with = optionals.id_ends_with, id_not_ends_with = optionals.id_not_ends_with, name = optionals.name, name_not = optionals.name_not, name_in = optionals.name_in, name_not_in = optionals.name_not_in, name_lt = optionals.name_lt, name_lte = optionals.name_lte, name_gt = optionals.name_gt, name_gte = optionals.name_gte, name_contains = optionals.name_contains, name_not_contains = optionals.name_not_contains, name_starts_with = optionals.name_starts_with, name_not_starts_with = optionals.name_not_starts_with, name_ends_with = optionals.name_ends_with, name_not_ends_with = optionals.name_not_ends_with, email = optionals.email, email_not = optionals.email_not, email_in = optionals.email_in, email_not_in = optionals.email_not_in, email_lt = optionals.email_lt, email_lte = optionals.email_lte, email_gt = optionals.email_gt, email_gte = optionals.email_gte, email_contains = optionals.email_contains, email_not_contains = optionals.email_not_contains, email_starts_with = optionals.email_starts_with, email_not_starts_with = optionals.email_not_starts_with, email_ends_with = optionals.email_ends_with, email_not_ends_with = optionals.email_not_ends_with, password = optionals.password, password_not = optionals.password_not, password_in = optionals.password_in, password_not_in = optionals.password_not_in, password_lt = optionals.password_lt, password_lte = optionals.password_lte, password_gt = optionals.password_gt, password_gte = optionals.password_gte, password_contains = optionals.password_contains, password_not_contains = optionals.password_not_contains, password_starts_with = optionals.password_starts_with, password_not_starts_with = optionals.password_not_starts_with, password_ends_with = optionals.password_ends_with, password_not_ends_with = optionals.password_not_ends_with, exercises_every = optionals.exercises_every, exercises_some = optionals.exercises_some, exercises_none = optionals.exercises_none }


type alias UserWhereInputOptionalFields =
    { and : OptionalArgument (List UserWhereInput), or : OptionalArgument (List UserWhereInput), not : OptionalArgument (List UserWhereInput), id : OptionalArgument Api.Scalar.Id, id_not : OptionalArgument Api.Scalar.Id, id_in : OptionalArgument (List Api.Scalar.Id), id_not_in : OptionalArgument (List Api.Scalar.Id), id_lt : OptionalArgument Api.Scalar.Id, id_lte : OptionalArgument Api.Scalar.Id, id_gt : OptionalArgument Api.Scalar.Id, id_gte : OptionalArgument Api.Scalar.Id, id_contains : OptionalArgument Api.Scalar.Id, id_not_contains : OptionalArgument Api.Scalar.Id, id_starts_with : OptionalArgument Api.Scalar.Id, id_not_starts_with : OptionalArgument Api.Scalar.Id, id_ends_with : OptionalArgument Api.Scalar.Id, id_not_ends_with : OptionalArgument Api.Scalar.Id, name : OptionalArgument String, name_not : OptionalArgument String, name_in : OptionalArgument (List String), name_not_in : OptionalArgument (List String), name_lt : OptionalArgument String, name_lte : OptionalArgument String, name_gt : OptionalArgument String, name_gte : OptionalArgument String, name_contains : OptionalArgument String, name_not_contains : OptionalArgument String, name_starts_with : OptionalArgument String, name_not_starts_with : OptionalArgument String, name_ends_with : OptionalArgument String, name_not_ends_with : OptionalArgument String, email : OptionalArgument String, email_not : OptionalArgument String, email_in : OptionalArgument (List String), email_not_in : OptionalArgument (List String), email_lt : OptionalArgument String, email_lte : OptionalArgument String, email_gt : OptionalArgument String, email_gte : OptionalArgument String, email_contains : OptionalArgument String, email_not_contains : OptionalArgument String, email_starts_with : OptionalArgument String, email_not_starts_with : OptionalArgument String, email_ends_with : OptionalArgument String, email_not_ends_with : OptionalArgument String, password : OptionalArgument String, password_not : OptionalArgument String, password_in : OptionalArgument (List String), password_not_in : OptionalArgument (List String), password_lt : OptionalArgument String, password_lte : OptionalArgument String, password_gt : OptionalArgument String, password_gte : OptionalArgument String, password_contains : OptionalArgument String, password_not_contains : OptionalArgument String, password_starts_with : OptionalArgument String, password_not_starts_with : OptionalArgument String, password_ends_with : OptionalArgument String, password_not_ends_with : OptionalArgument String, exercises_every : OptionalArgument ExerciseWhereInput, exercises_some : OptionalArgument ExerciseWhereInput, exercises_none : OptionalArgument ExerciseWhereInput }


{-| Type alias for the `UserWhereInput` attributes. Note that this type
needs to use the `UserWhereInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/graphqelm/issues/33>.
-}
type alias UserWhereInputRaw =
    { and : OptionalArgument (List UserWhereInput), or : OptionalArgument (List UserWhereInput), not : OptionalArgument (List UserWhereInput), id : OptionalArgument Api.Scalar.Id, id_not : OptionalArgument Api.Scalar.Id, id_in : OptionalArgument (List Api.Scalar.Id), id_not_in : OptionalArgument (List Api.Scalar.Id), id_lt : OptionalArgument Api.Scalar.Id, id_lte : OptionalArgument Api.Scalar.Id, id_gt : OptionalArgument Api.Scalar.Id, id_gte : OptionalArgument Api.Scalar.Id, id_contains : OptionalArgument Api.Scalar.Id, id_not_contains : OptionalArgument Api.Scalar.Id, id_starts_with : OptionalArgument Api.Scalar.Id, id_not_starts_with : OptionalArgument Api.Scalar.Id, id_ends_with : OptionalArgument Api.Scalar.Id, id_not_ends_with : OptionalArgument Api.Scalar.Id, name : OptionalArgument String, name_not : OptionalArgument String, name_in : OptionalArgument (List String), name_not_in : OptionalArgument (List String), name_lt : OptionalArgument String, name_lte : OptionalArgument String, name_gt : OptionalArgument String, name_gte : OptionalArgument String, name_contains : OptionalArgument String, name_not_contains : OptionalArgument String, name_starts_with : OptionalArgument String, name_not_starts_with : OptionalArgument String, name_ends_with : OptionalArgument String, name_not_ends_with : OptionalArgument String, email : OptionalArgument String, email_not : OptionalArgument String, email_in : OptionalArgument (List String), email_not_in : OptionalArgument (List String), email_lt : OptionalArgument String, email_lte : OptionalArgument String, email_gt : OptionalArgument String, email_gte : OptionalArgument String, email_contains : OptionalArgument String, email_not_contains : OptionalArgument String, email_starts_with : OptionalArgument String, email_not_starts_with : OptionalArgument String, email_ends_with : OptionalArgument String, email_not_ends_with : OptionalArgument String, password : OptionalArgument String, password_not : OptionalArgument String, password_in : OptionalArgument (List String), password_not_in : OptionalArgument (List String), password_lt : OptionalArgument String, password_lte : OptionalArgument String, password_gt : OptionalArgument String, password_gte : OptionalArgument String, password_contains : OptionalArgument String, password_not_contains : OptionalArgument String, password_starts_with : OptionalArgument String, password_not_starts_with : OptionalArgument String, password_ends_with : OptionalArgument String, password_not_ends_with : OptionalArgument String, exercises_every : OptionalArgument ExerciseWhereInput, exercises_some : OptionalArgument ExerciseWhereInput, exercises_none : OptionalArgument ExerciseWhereInput }


{-| Type for the UserWhereInput input object.
-}
type UserWhereInput
    = UserWhereInput UserWhereInputRaw


{-| Encode a UserWhereInput into a value that can be used as an argument.
-}
encodeUserWhereInput : UserWhereInput -> Value
encodeUserWhereInput (UserWhereInput input) =
    Encode.maybeObject
        [ ( "AND", (encodeUserWhereInput |> Encode.list) |> Encode.optional input.and ), ( "OR", (encodeUserWhereInput |> Encode.list) |> Encode.optional input.or ), ( "NOT", (encodeUserWhereInput |> Encode.list) |> Encode.optional input.not ), ( "id", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id ), ( "id_not", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_not ), ( "id_in", ((\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.list) |> Encode.optional input.id_in ), ( "id_not_in", ((\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.list) |> Encode.optional input.id_not_in ), ( "id_lt", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_lt ), ( "id_lte", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_lte ), ( "id_gt", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_gt ), ( "id_gte", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_gte ), ( "id_contains", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_contains ), ( "id_not_contains", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_not_contains ), ( "id_starts_with", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_starts_with ), ( "id_not_starts_with", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_not_starts_with ), ( "id_ends_with", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_ends_with ), ( "id_not_ends_with", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_not_ends_with ), ( "name", Encode.string |> Encode.optional input.name ), ( "name_not", Encode.string |> Encode.optional input.name_not ), ( "name_in", (Encode.string |> Encode.list) |> Encode.optional input.name_in ), ( "name_not_in", (Encode.string |> Encode.list) |> Encode.optional input.name_not_in ), ( "name_lt", Encode.string |> Encode.optional input.name_lt ), ( "name_lte", Encode.string |> Encode.optional input.name_lte ), ( "name_gt", Encode.string |> Encode.optional input.name_gt ), ( "name_gte", Encode.string |> Encode.optional input.name_gte ), ( "name_contains", Encode.string |> Encode.optional input.name_contains ), ( "name_not_contains", Encode.string |> Encode.optional input.name_not_contains ), ( "name_starts_with", Encode.string |> Encode.optional input.name_starts_with ), ( "name_not_starts_with", Encode.string |> Encode.optional input.name_not_starts_with ), ( "name_ends_with", Encode.string |> Encode.optional input.name_ends_with ), ( "name_not_ends_with", Encode.string |> Encode.optional input.name_not_ends_with ), ( "email", Encode.string |> Encode.optional input.email ), ( "email_not", Encode.string |> Encode.optional input.email_not ), ( "email_in", (Encode.string |> Encode.list) |> Encode.optional input.email_in ), ( "email_not_in", (Encode.string |> Encode.list) |> Encode.optional input.email_not_in ), ( "email_lt", Encode.string |> Encode.optional input.email_lt ), ( "email_lte", Encode.string |> Encode.optional input.email_lte ), ( "email_gt", Encode.string |> Encode.optional input.email_gt ), ( "email_gte", Encode.string |> Encode.optional input.email_gte ), ( "email_contains", Encode.string |> Encode.optional input.email_contains ), ( "email_not_contains", Encode.string |> Encode.optional input.email_not_contains ), ( "email_starts_with", Encode.string |> Encode.optional input.email_starts_with ), ( "email_not_starts_with", Encode.string |> Encode.optional input.email_not_starts_with ), ( "email_ends_with", Encode.string |> Encode.optional input.email_ends_with ), ( "email_not_ends_with", Encode.string |> Encode.optional input.email_not_ends_with ), ( "password", Encode.string |> Encode.optional input.password ), ( "password_not", Encode.string |> Encode.optional input.password_not ), ( "password_in", (Encode.string |> Encode.list) |> Encode.optional input.password_in ), ( "password_not_in", (Encode.string |> Encode.list) |> Encode.optional input.password_not_in ), ( "password_lt", Encode.string |> Encode.optional input.password_lt ), ( "password_lte", Encode.string |> Encode.optional input.password_lte ), ( "password_gt", Encode.string |> Encode.optional input.password_gt ), ( "password_gte", Encode.string |> Encode.optional input.password_gte ), ( "password_contains", Encode.string |> Encode.optional input.password_contains ), ( "password_not_contains", Encode.string |> Encode.optional input.password_not_contains ), ( "password_starts_with", Encode.string |> Encode.optional input.password_starts_with ), ( "password_not_starts_with", Encode.string |> Encode.optional input.password_not_starts_with ), ( "password_ends_with", Encode.string |> Encode.optional input.password_ends_with ), ( "password_not_ends_with", Encode.string |> Encode.optional input.password_not_ends_with ), ( "exercises_every", encodeExerciseWhereInput |> Encode.optional input.exercises_every ), ( "exercises_some", encodeExerciseWhereInput |> Encode.optional input.exercises_some ), ( "exercises_none", encodeExerciseWhereInput |> Encode.optional input.exercises_none ) ]


buildUserWhereUniqueInput : (UserWhereUniqueInputOptionalFields -> UserWhereUniqueInputOptionalFields) -> UserWhereUniqueInput
buildUserWhereUniqueInput fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, email = Absent }
    in
    { id = optionals.id, email = optionals.email }


type alias UserWhereUniqueInputOptionalFields =
    { id : OptionalArgument Api.Scalar.Id, email : OptionalArgument String }


{-| Type for the UserWhereUniqueInput input object.
-}
type alias UserWhereUniqueInput =
    { id : OptionalArgument Api.Scalar.Id, email : OptionalArgument String }


{-| Encode a UserWhereUniqueInput into a value that can be used as an argument.
-}
encodeUserWhereUniqueInput : UserWhereUniqueInput -> Value
encodeUserWhereUniqueInput input =
    Encode.maybeObject
        [ ( "id", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id ), ( "email", Encode.string |> Encode.optional input.email ) ]


buildWordCreateInput : WordCreateInputRequiredFields -> WordCreateInput
buildWordCreateInput required =
    { word = required.word, group = required.group, beginning = required.beginning, ending = required.ending, vowel = required.vowel }


type alias WordCreateInputRequiredFields =
    { word : String, group : String, beginning : String, ending : String, vowel : String }


{-| Type for the WordCreateInput input object.
-}
type alias WordCreateInput =
    { word : String, group : String, beginning : String, ending : String, vowel : String }


{-| Encode a WordCreateInput into a value that can be used as an argument.
-}
encodeWordCreateInput : WordCreateInput -> Value
encodeWordCreateInput input =
    Encode.maybeObject
        [ ( "word", Encode.string input.word |> Just ), ( "group", Encode.string input.group |> Just ), ( "beginning", Encode.string input.beginning |> Just ), ( "ending", Encode.string input.ending |> Just ), ( "vowel", Encode.string input.vowel |> Just ) ]


buildWordSubscriptionWhereInput : (WordSubscriptionWhereInputOptionalFields -> WordSubscriptionWhereInputOptionalFields) -> WordSubscriptionWhereInput
buildWordSubscriptionWhereInput fillOptionals =
    let
        optionals =
            fillOptionals
                { and = Absent, or = Absent, not = Absent, mutation_in = Absent, updatedFields_contains = Absent, updatedFields_contains_every = Absent, updatedFields_contains_some = Absent, node = Absent }
    in
    WordSubscriptionWhereInput { and = optionals.and, or = optionals.or, not = optionals.not, mutation_in = optionals.mutation_in, updatedFields_contains = optionals.updatedFields_contains, updatedFields_contains_every = optionals.updatedFields_contains_every, updatedFields_contains_some = optionals.updatedFields_contains_some, node = optionals.node }


type alias WordSubscriptionWhereInputOptionalFields =
    { and : OptionalArgument (List WordSubscriptionWhereInput), or : OptionalArgument (List WordSubscriptionWhereInput), not : OptionalArgument (List WordSubscriptionWhereInput), mutation_in : OptionalArgument (List Api.Enum.MutationType.MutationType), updatedFields_contains : OptionalArgument String, updatedFields_contains_every : OptionalArgument (List String), updatedFields_contains_some : OptionalArgument (List String), node : OptionalArgument WordWhereInput }


{-| Type alias for the `WordSubscriptionWhereInput` attributes. Note that this type
needs to use the `WordSubscriptionWhereInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/graphqelm/issues/33>.
-}
type alias WordSubscriptionWhereInputRaw =
    { and : OptionalArgument (List WordSubscriptionWhereInput), or : OptionalArgument (List WordSubscriptionWhereInput), not : OptionalArgument (List WordSubscriptionWhereInput), mutation_in : OptionalArgument (List Api.Enum.MutationType.MutationType), updatedFields_contains : OptionalArgument String, updatedFields_contains_every : OptionalArgument (List String), updatedFields_contains_some : OptionalArgument (List String), node : OptionalArgument WordWhereInput }


{-| Type for the WordSubscriptionWhereInput input object.
-}
type WordSubscriptionWhereInput
    = WordSubscriptionWhereInput WordSubscriptionWhereInputRaw


{-| Encode a WordSubscriptionWhereInput into a value that can be used as an argument.
-}
encodeWordSubscriptionWhereInput : WordSubscriptionWhereInput -> Value
encodeWordSubscriptionWhereInput (WordSubscriptionWhereInput input) =
    Encode.maybeObject
        [ ( "AND", (encodeWordSubscriptionWhereInput |> Encode.list) |> Encode.optional input.and ), ( "OR", (encodeWordSubscriptionWhereInput |> Encode.list) |> Encode.optional input.or ), ( "NOT", (encodeWordSubscriptionWhereInput |> Encode.list) |> Encode.optional input.not ), ( "mutation_in", (Encode.enum Api.Enum.MutationType.toString |> Encode.list) |> Encode.optional input.mutation_in ), ( "updatedFields_contains", Encode.string |> Encode.optional input.updatedFields_contains ), ( "updatedFields_contains_every", (Encode.string |> Encode.list) |> Encode.optional input.updatedFields_contains_every ), ( "updatedFields_contains_some", (Encode.string |> Encode.list) |> Encode.optional input.updatedFields_contains_some ), ( "node", encodeWordWhereInput |> Encode.optional input.node ) ]


buildWordUpdateInput : (WordUpdateInputOptionalFields -> WordUpdateInputOptionalFields) -> WordUpdateInput
buildWordUpdateInput fillOptionals =
    let
        optionals =
            fillOptionals
                { word = Absent, group = Absent, beginning = Absent, ending = Absent, vowel = Absent }
    in
    { word = optionals.word, group = optionals.group, beginning = optionals.beginning, ending = optionals.ending, vowel = optionals.vowel }


type alias WordUpdateInputOptionalFields =
    { word : OptionalArgument String, group : OptionalArgument String, beginning : OptionalArgument String, ending : OptionalArgument String, vowel : OptionalArgument String }


{-| Type for the WordUpdateInput input object.
-}
type alias WordUpdateInput =
    { word : OptionalArgument String, group : OptionalArgument String, beginning : OptionalArgument String, ending : OptionalArgument String, vowel : OptionalArgument String }


{-| Encode a WordUpdateInput into a value that can be used as an argument.
-}
encodeWordUpdateInput : WordUpdateInput -> Value
encodeWordUpdateInput input =
    Encode.maybeObject
        [ ( "word", Encode.string |> Encode.optional input.word ), ( "group", Encode.string |> Encode.optional input.group ), ( "beginning", Encode.string |> Encode.optional input.beginning ), ( "ending", Encode.string |> Encode.optional input.ending ), ( "vowel", Encode.string |> Encode.optional input.vowel ) ]


buildWordWhereInput : (WordWhereInputOptionalFields -> WordWhereInputOptionalFields) -> WordWhereInput
buildWordWhereInput fillOptionals =
    let
        optionals =
            fillOptionals
                { and = Absent, or = Absent, not = Absent, id = Absent, id_not = Absent, id_in = Absent, id_not_in = Absent, id_lt = Absent, id_lte = Absent, id_gt = Absent, id_gte = Absent, id_contains = Absent, id_not_contains = Absent, id_starts_with = Absent, id_not_starts_with = Absent, id_ends_with = Absent, id_not_ends_with = Absent, word = Absent, word_not = Absent, word_in = Absent, word_not_in = Absent, word_lt = Absent, word_lte = Absent, word_gt = Absent, word_gte = Absent, word_contains = Absent, word_not_contains = Absent, word_starts_with = Absent, word_not_starts_with = Absent, word_ends_with = Absent, word_not_ends_with = Absent, group = Absent, group_not = Absent, group_in = Absent, group_not_in = Absent, group_lt = Absent, group_lte = Absent, group_gt = Absent, group_gte = Absent, group_contains = Absent, group_not_contains = Absent, group_starts_with = Absent, group_not_starts_with = Absent, group_ends_with = Absent, group_not_ends_with = Absent, beginning = Absent, beginning_not = Absent, beginning_in = Absent, beginning_not_in = Absent, beginning_lt = Absent, beginning_lte = Absent, beginning_gt = Absent, beginning_gte = Absent, beginning_contains = Absent, beginning_not_contains = Absent, beginning_starts_with = Absent, beginning_not_starts_with = Absent, beginning_ends_with = Absent, beginning_not_ends_with = Absent, ending = Absent, ending_not = Absent, ending_in = Absent, ending_not_in = Absent, ending_lt = Absent, ending_lte = Absent, ending_gt = Absent, ending_gte = Absent, ending_contains = Absent, ending_not_contains = Absent, ending_starts_with = Absent, ending_not_starts_with = Absent, ending_ends_with = Absent, ending_not_ends_with = Absent, vowel = Absent, vowel_not = Absent, vowel_in = Absent, vowel_not_in = Absent, vowel_lt = Absent, vowel_lte = Absent, vowel_gt = Absent, vowel_gte = Absent, vowel_contains = Absent, vowel_not_contains = Absent, vowel_starts_with = Absent, vowel_not_starts_with = Absent, vowel_ends_with = Absent, vowel_not_ends_with = Absent }
    in
    WordWhereInput { and = optionals.and, or = optionals.or, not = optionals.not, id = optionals.id, id_not = optionals.id_not, id_in = optionals.id_in, id_not_in = optionals.id_not_in, id_lt = optionals.id_lt, id_lte = optionals.id_lte, id_gt = optionals.id_gt, id_gte = optionals.id_gte, id_contains = optionals.id_contains, id_not_contains = optionals.id_not_contains, id_starts_with = optionals.id_starts_with, id_not_starts_with = optionals.id_not_starts_with, id_ends_with = optionals.id_ends_with, id_not_ends_with = optionals.id_not_ends_with, word = optionals.word, word_not = optionals.word_not, word_in = optionals.word_in, word_not_in = optionals.word_not_in, word_lt = optionals.word_lt, word_lte = optionals.word_lte, word_gt = optionals.word_gt, word_gte = optionals.word_gte, word_contains = optionals.word_contains, word_not_contains = optionals.word_not_contains, word_starts_with = optionals.word_starts_with, word_not_starts_with = optionals.word_not_starts_with, word_ends_with = optionals.word_ends_with, word_not_ends_with = optionals.word_not_ends_with, group = optionals.group, group_not = optionals.group_not, group_in = optionals.group_in, group_not_in = optionals.group_not_in, group_lt = optionals.group_lt, group_lte = optionals.group_lte, group_gt = optionals.group_gt, group_gte = optionals.group_gte, group_contains = optionals.group_contains, group_not_contains = optionals.group_not_contains, group_starts_with = optionals.group_starts_with, group_not_starts_with = optionals.group_not_starts_with, group_ends_with = optionals.group_ends_with, group_not_ends_with = optionals.group_not_ends_with, beginning = optionals.beginning, beginning_not = optionals.beginning_not, beginning_in = optionals.beginning_in, beginning_not_in = optionals.beginning_not_in, beginning_lt = optionals.beginning_lt, beginning_lte = optionals.beginning_lte, beginning_gt = optionals.beginning_gt, beginning_gte = optionals.beginning_gte, beginning_contains = optionals.beginning_contains, beginning_not_contains = optionals.beginning_not_contains, beginning_starts_with = optionals.beginning_starts_with, beginning_not_starts_with = optionals.beginning_not_starts_with, beginning_ends_with = optionals.beginning_ends_with, beginning_not_ends_with = optionals.beginning_not_ends_with, ending = optionals.ending, ending_not = optionals.ending_not, ending_in = optionals.ending_in, ending_not_in = optionals.ending_not_in, ending_lt = optionals.ending_lt, ending_lte = optionals.ending_lte, ending_gt = optionals.ending_gt, ending_gte = optionals.ending_gte, ending_contains = optionals.ending_contains, ending_not_contains = optionals.ending_not_contains, ending_starts_with = optionals.ending_starts_with, ending_not_starts_with = optionals.ending_not_starts_with, ending_ends_with = optionals.ending_ends_with, ending_not_ends_with = optionals.ending_not_ends_with, vowel = optionals.vowel, vowel_not = optionals.vowel_not, vowel_in = optionals.vowel_in, vowel_not_in = optionals.vowel_not_in, vowel_lt = optionals.vowel_lt, vowel_lte = optionals.vowel_lte, vowel_gt = optionals.vowel_gt, vowel_gte = optionals.vowel_gte, vowel_contains = optionals.vowel_contains, vowel_not_contains = optionals.vowel_not_contains, vowel_starts_with = optionals.vowel_starts_with, vowel_not_starts_with = optionals.vowel_not_starts_with, vowel_ends_with = optionals.vowel_ends_with, vowel_not_ends_with = optionals.vowel_not_ends_with }


type alias WordWhereInputOptionalFields =
    { and : OptionalArgument (List WordWhereInput), or : OptionalArgument (List WordWhereInput), not : OptionalArgument (List WordWhereInput), id : OptionalArgument Api.Scalar.Id, id_not : OptionalArgument Api.Scalar.Id, id_in : OptionalArgument (List Api.Scalar.Id), id_not_in : OptionalArgument (List Api.Scalar.Id), id_lt : OptionalArgument Api.Scalar.Id, id_lte : OptionalArgument Api.Scalar.Id, id_gt : OptionalArgument Api.Scalar.Id, id_gte : OptionalArgument Api.Scalar.Id, id_contains : OptionalArgument Api.Scalar.Id, id_not_contains : OptionalArgument Api.Scalar.Id, id_starts_with : OptionalArgument Api.Scalar.Id, id_not_starts_with : OptionalArgument Api.Scalar.Id, id_ends_with : OptionalArgument Api.Scalar.Id, id_not_ends_with : OptionalArgument Api.Scalar.Id, word : OptionalArgument String, word_not : OptionalArgument String, word_in : OptionalArgument (List String), word_not_in : OptionalArgument (List String), word_lt : OptionalArgument String, word_lte : OptionalArgument String, word_gt : OptionalArgument String, word_gte : OptionalArgument String, word_contains : OptionalArgument String, word_not_contains : OptionalArgument String, word_starts_with : OptionalArgument String, word_not_starts_with : OptionalArgument String, word_ends_with : OptionalArgument String, word_not_ends_with : OptionalArgument String, group : OptionalArgument String, group_not : OptionalArgument String, group_in : OptionalArgument (List String), group_not_in : OptionalArgument (List String), group_lt : OptionalArgument String, group_lte : OptionalArgument String, group_gt : OptionalArgument String, group_gte : OptionalArgument String, group_contains : OptionalArgument String, group_not_contains : OptionalArgument String, group_starts_with : OptionalArgument String, group_not_starts_with : OptionalArgument String, group_ends_with : OptionalArgument String, group_not_ends_with : OptionalArgument String, beginning : OptionalArgument String, beginning_not : OptionalArgument String, beginning_in : OptionalArgument (List String), beginning_not_in : OptionalArgument (List String), beginning_lt : OptionalArgument String, beginning_lte : OptionalArgument String, beginning_gt : OptionalArgument String, beginning_gte : OptionalArgument String, beginning_contains : OptionalArgument String, beginning_not_contains : OptionalArgument String, beginning_starts_with : OptionalArgument String, beginning_not_starts_with : OptionalArgument String, beginning_ends_with : OptionalArgument String, beginning_not_ends_with : OptionalArgument String, ending : OptionalArgument String, ending_not : OptionalArgument String, ending_in : OptionalArgument (List String), ending_not_in : OptionalArgument (List String), ending_lt : OptionalArgument String, ending_lte : OptionalArgument String, ending_gt : OptionalArgument String, ending_gte : OptionalArgument String, ending_contains : OptionalArgument String, ending_not_contains : OptionalArgument String, ending_starts_with : OptionalArgument String, ending_not_starts_with : OptionalArgument String, ending_ends_with : OptionalArgument String, ending_not_ends_with : OptionalArgument String, vowel : OptionalArgument String, vowel_not : OptionalArgument String, vowel_in : OptionalArgument (List String), vowel_not_in : OptionalArgument (List String), vowel_lt : OptionalArgument String, vowel_lte : OptionalArgument String, vowel_gt : OptionalArgument String, vowel_gte : OptionalArgument String, vowel_contains : OptionalArgument String, vowel_not_contains : OptionalArgument String, vowel_starts_with : OptionalArgument String, vowel_not_starts_with : OptionalArgument String, vowel_ends_with : OptionalArgument String, vowel_not_ends_with : OptionalArgument String }


{-| Type alias for the `WordWhereInput` attributes. Note that this type
needs to use the `WordWhereInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/graphqelm/issues/33>.
-}
type alias WordWhereInputRaw =
    { and : OptionalArgument (List WordWhereInput), or : OptionalArgument (List WordWhereInput), not : OptionalArgument (List WordWhereInput), id : OptionalArgument Api.Scalar.Id, id_not : OptionalArgument Api.Scalar.Id, id_in : OptionalArgument (List Api.Scalar.Id), id_not_in : OptionalArgument (List Api.Scalar.Id), id_lt : OptionalArgument Api.Scalar.Id, id_lte : OptionalArgument Api.Scalar.Id, id_gt : OptionalArgument Api.Scalar.Id, id_gte : OptionalArgument Api.Scalar.Id, id_contains : OptionalArgument Api.Scalar.Id, id_not_contains : OptionalArgument Api.Scalar.Id, id_starts_with : OptionalArgument Api.Scalar.Id, id_not_starts_with : OptionalArgument Api.Scalar.Id, id_ends_with : OptionalArgument Api.Scalar.Id, id_not_ends_with : OptionalArgument Api.Scalar.Id, word : OptionalArgument String, word_not : OptionalArgument String, word_in : OptionalArgument (List String), word_not_in : OptionalArgument (List String), word_lt : OptionalArgument String, word_lte : OptionalArgument String, word_gt : OptionalArgument String, word_gte : OptionalArgument String, word_contains : OptionalArgument String, word_not_contains : OptionalArgument String, word_starts_with : OptionalArgument String, word_not_starts_with : OptionalArgument String, word_ends_with : OptionalArgument String, word_not_ends_with : OptionalArgument String, group : OptionalArgument String, group_not : OptionalArgument String, group_in : OptionalArgument (List String), group_not_in : OptionalArgument (List String), group_lt : OptionalArgument String, group_lte : OptionalArgument String, group_gt : OptionalArgument String, group_gte : OptionalArgument String, group_contains : OptionalArgument String, group_not_contains : OptionalArgument String, group_starts_with : OptionalArgument String, group_not_starts_with : OptionalArgument String, group_ends_with : OptionalArgument String, group_not_ends_with : OptionalArgument String, beginning : OptionalArgument String, beginning_not : OptionalArgument String, beginning_in : OptionalArgument (List String), beginning_not_in : OptionalArgument (List String), beginning_lt : OptionalArgument String, beginning_lte : OptionalArgument String, beginning_gt : OptionalArgument String, beginning_gte : OptionalArgument String, beginning_contains : OptionalArgument String, beginning_not_contains : OptionalArgument String, beginning_starts_with : OptionalArgument String, beginning_not_starts_with : OptionalArgument String, beginning_ends_with : OptionalArgument String, beginning_not_ends_with : OptionalArgument String, ending : OptionalArgument String, ending_not : OptionalArgument String, ending_in : OptionalArgument (List String), ending_not_in : OptionalArgument (List String), ending_lt : OptionalArgument String, ending_lte : OptionalArgument String, ending_gt : OptionalArgument String, ending_gte : OptionalArgument String, ending_contains : OptionalArgument String, ending_not_contains : OptionalArgument String, ending_starts_with : OptionalArgument String, ending_not_starts_with : OptionalArgument String, ending_ends_with : OptionalArgument String, ending_not_ends_with : OptionalArgument String, vowel : OptionalArgument String, vowel_not : OptionalArgument String, vowel_in : OptionalArgument (List String), vowel_not_in : OptionalArgument (List String), vowel_lt : OptionalArgument String, vowel_lte : OptionalArgument String, vowel_gt : OptionalArgument String, vowel_gte : OptionalArgument String, vowel_contains : OptionalArgument String, vowel_not_contains : OptionalArgument String, vowel_starts_with : OptionalArgument String, vowel_not_starts_with : OptionalArgument String, vowel_ends_with : OptionalArgument String, vowel_not_ends_with : OptionalArgument String }


{-| Type for the WordWhereInput input object.
-}
type WordWhereInput
    = WordWhereInput WordWhereInputRaw


{-| Encode a WordWhereInput into a value that can be used as an argument.
-}
encodeWordWhereInput : WordWhereInput -> Value
encodeWordWhereInput (WordWhereInput input) =
    Encode.maybeObject
        [ ( "AND", (encodeWordWhereInput |> Encode.list) |> Encode.optional input.and ), ( "OR", (encodeWordWhereInput |> Encode.list) |> Encode.optional input.or ), ( "NOT", (encodeWordWhereInput |> Encode.list) |> Encode.optional input.not ), ( "id", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id ), ( "id_not", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_not ), ( "id_in", ((\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.list) |> Encode.optional input.id_in ), ( "id_not_in", ((\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.list) |> Encode.optional input.id_not_in ), ( "id_lt", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_lt ), ( "id_lte", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_lte ), ( "id_gt", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_gt ), ( "id_gte", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_gte ), ( "id_contains", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_contains ), ( "id_not_contains", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_not_contains ), ( "id_starts_with", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_starts_with ), ( "id_not_starts_with", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_not_starts_with ), ( "id_ends_with", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_ends_with ), ( "id_not_ends_with", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id_not_ends_with ), ( "word", Encode.string |> Encode.optional input.word ), ( "word_not", Encode.string |> Encode.optional input.word_not ), ( "word_in", (Encode.string |> Encode.list) |> Encode.optional input.word_in ), ( "word_not_in", (Encode.string |> Encode.list) |> Encode.optional input.word_not_in ), ( "word_lt", Encode.string |> Encode.optional input.word_lt ), ( "word_lte", Encode.string |> Encode.optional input.word_lte ), ( "word_gt", Encode.string |> Encode.optional input.word_gt ), ( "word_gte", Encode.string |> Encode.optional input.word_gte ), ( "word_contains", Encode.string |> Encode.optional input.word_contains ), ( "word_not_contains", Encode.string |> Encode.optional input.word_not_contains ), ( "word_starts_with", Encode.string |> Encode.optional input.word_starts_with ), ( "word_not_starts_with", Encode.string |> Encode.optional input.word_not_starts_with ), ( "word_ends_with", Encode.string |> Encode.optional input.word_ends_with ), ( "word_not_ends_with", Encode.string |> Encode.optional input.word_not_ends_with ), ( "group", Encode.string |> Encode.optional input.group ), ( "group_not", Encode.string |> Encode.optional input.group_not ), ( "group_in", (Encode.string |> Encode.list) |> Encode.optional input.group_in ), ( "group_not_in", (Encode.string |> Encode.list) |> Encode.optional input.group_not_in ), ( "group_lt", Encode.string |> Encode.optional input.group_lt ), ( "group_lte", Encode.string |> Encode.optional input.group_lte ), ( "group_gt", Encode.string |> Encode.optional input.group_gt ), ( "group_gte", Encode.string |> Encode.optional input.group_gte ), ( "group_contains", Encode.string |> Encode.optional input.group_contains ), ( "group_not_contains", Encode.string |> Encode.optional input.group_not_contains ), ( "group_starts_with", Encode.string |> Encode.optional input.group_starts_with ), ( "group_not_starts_with", Encode.string |> Encode.optional input.group_not_starts_with ), ( "group_ends_with", Encode.string |> Encode.optional input.group_ends_with ), ( "group_not_ends_with", Encode.string |> Encode.optional input.group_not_ends_with ), ( "beginning", Encode.string |> Encode.optional input.beginning ), ( "beginning_not", Encode.string |> Encode.optional input.beginning_not ), ( "beginning_in", (Encode.string |> Encode.list) |> Encode.optional input.beginning_in ), ( "beginning_not_in", (Encode.string |> Encode.list) |> Encode.optional input.beginning_not_in ), ( "beginning_lt", Encode.string |> Encode.optional input.beginning_lt ), ( "beginning_lte", Encode.string |> Encode.optional input.beginning_lte ), ( "beginning_gt", Encode.string |> Encode.optional input.beginning_gt ), ( "beginning_gte", Encode.string |> Encode.optional input.beginning_gte ), ( "beginning_contains", Encode.string |> Encode.optional input.beginning_contains ), ( "beginning_not_contains", Encode.string |> Encode.optional input.beginning_not_contains ), ( "beginning_starts_with", Encode.string |> Encode.optional input.beginning_starts_with ), ( "beginning_not_starts_with", Encode.string |> Encode.optional input.beginning_not_starts_with ), ( "beginning_ends_with", Encode.string |> Encode.optional input.beginning_ends_with ), ( "beginning_not_ends_with", Encode.string |> Encode.optional input.beginning_not_ends_with ), ( "ending", Encode.string |> Encode.optional input.ending ), ( "ending_not", Encode.string |> Encode.optional input.ending_not ), ( "ending_in", (Encode.string |> Encode.list) |> Encode.optional input.ending_in ), ( "ending_not_in", (Encode.string |> Encode.list) |> Encode.optional input.ending_not_in ), ( "ending_lt", Encode.string |> Encode.optional input.ending_lt ), ( "ending_lte", Encode.string |> Encode.optional input.ending_lte ), ( "ending_gt", Encode.string |> Encode.optional input.ending_gt ), ( "ending_gte", Encode.string |> Encode.optional input.ending_gte ), ( "ending_contains", Encode.string |> Encode.optional input.ending_contains ), ( "ending_not_contains", Encode.string |> Encode.optional input.ending_not_contains ), ( "ending_starts_with", Encode.string |> Encode.optional input.ending_starts_with ), ( "ending_not_starts_with", Encode.string |> Encode.optional input.ending_not_starts_with ), ( "ending_ends_with", Encode.string |> Encode.optional input.ending_ends_with ), ( "ending_not_ends_with", Encode.string |> Encode.optional input.ending_not_ends_with ), ( "vowel", Encode.string |> Encode.optional input.vowel ), ( "vowel_not", Encode.string |> Encode.optional input.vowel_not ), ( "vowel_in", (Encode.string |> Encode.list) |> Encode.optional input.vowel_in ), ( "vowel_not_in", (Encode.string |> Encode.list) |> Encode.optional input.vowel_not_in ), ( "vowel_lt", Encode.string |> Encode.optional input.vowel_lt ), ( "vowel_lte", Encode.string |> Encode.optional input.vowel_lte ), ( "vowel_gt", Encode.string |> Encode.optional input.vowel_gt ), ( "vowel_gte", Encode.string |> Encode.optional input.vowel_gte ), ( "vowel_contains", Encode.string |> Encode.optional input.vowel_contains ), ( "vowel_not_contains", Encode.string |> Encode.optional input.vowel_not_contains ), ( "vowel_starts_with", Encode.string |> Encode.optional input.vowel_starts_with ), ( "vowel_not_starts_with", Encode.string |> Encode.optional input.vowel_not_starts_with ), ( "vowel_ends_with", Encode.string |> Encode.optional input.vowel_ends_with ), ( "vowel_not_ends_with", Encode.string |> Encode.optional input.vowel_not_ends_with ) ]


buildWordWhereUniqueInput : (WordWhereUniqueInputOptionalFields -> WordWhereUniqueInputOptionalFields) -> WordWhereUniqueInput
buildWordWhereUniqueInput fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, word = Absent }
    in
    { id = optionals.id, word = optionals.word }


type alias WordWhereUniqueInputOptionalFields =
    { id : OptionalArgument Api.Scalar.Id, word : OptionalArgument String }


{-| Type for the WordWhereUniqueInput input object.
-}
type alias WordWhereUniqueInput =
    { id : OptionalArgument Api.Scalar.Id, word : OptionalArgument String }


{-| Encode a WordWhereUniqueInput into a value that can be used as an argument.
-}
encodeWordWhereUniqueInput : WordWhereUniqueInput -> Value
encodeWordWhereUniqueInput input =
    Encode.maybeObject
        [ ( "id", (\(Api.Scalar.Id raw) -> Encode.string raw) |> Encode.optional input.id ), ( "word", Encode.string |> Encode.optional input.word ) ]
